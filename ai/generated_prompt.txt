I am building an elixir phoenix server to host Magic the Gathering drafts.

I am trying to fix a bug with my cards import via seeds.exs.
It appears that Split Cards are loading incorrectly, for example:

    [
      <<202, 242, 131, 119, ...>>,
      <<0, 90, 136, ...>>,
      "Tatsunari, Toad Rider // Tatsunari, Toad Rider",
      nil,
      0.0,
      ...
    ],
    [
      <<168, 103, ...>>,
      <<1, ...>>,
      "Exterminator Magmarch // Exterminator Magmarch",
      ...
    ],

These come into the front end as:

{
            "id": "84a051e5-df37-4020-971c-1dd1bb40d023",
            "oracle_id": "403850c4-8f7f-47ec-8725-03ceee725f90",
            "name": "Neera, Wild Mage // Neera, Wild Mage",
            "mana_cost": null,
            "cmc": 0.0,
            "type_line": "Card // Card",
            "oracle_text": null,
            "power": null,
            "toughness": null,
            "colors": null,
            "color_identity": [],
            "set_code": "aclb",
            "rarity": "common",
            "foil": true,
            "image_uris": null,
            "legalities": {
                "alchemy": "not_legal",
                "brawl": "not_legal",
                "commander": "not_legal",
                "duel": "not_legal",
                "explorer": "not_legal",
                "future": "not_legal",
                "gladiator": "not_legal",
                "historic": "not_legal",
                "legacy": "not_legal",
                "modern": "not_legal",
                "oathbreaker": "not_legal",
                "oldschool": "not_legal",
                "pauper": "not_legal",
                "paupercommander": "not_legal",
                "penny": "not_legal",
                "pioneer": "not_legal",
                "predh": "not_legal",
                "premodern": "not_legal",
                "standard": "not_legal",
                "standardbrawl": "not_legal",
                "timeless": "not_legal",
                "vintage": "not_legal"
            },
            "inserted_at": "2025-04-01T23:34:51",
            "updated_at": "2025-04-01T23:34:51"
        },


This card for example is loaded from oracle_cards.json as:

{"object":"card","id":"84a051e5-df37-4020-971c-1dd1bb40d023","oracle_id":"403850c4-8f7f-47ec-8725-03ceee725f90","multiverse_ids":[],"name":"Neera, Wild Mage // Neera, Wild Mage","lang":"en","released_at":"2022-06-10","uri":"https://api.scryfall.com/cards/84a051e5-df37-4020-971c-1dd1bb40d023","scryfall_uri":"https://scryfall.com/card/aclb/74/neera-wild-mage-neera-wild-mage?utm_source=api","layout":"art_series","highres_image":true,"image_status":"highres_scan","cmc":0.0,"type_line":"Card // Card","color_identity":[],"keywords":[],"card_faces":[{"object":"card_face","name":"Neera, Wild Mage","mana_cost":"","type_line":"Card","oracle_text":"","colors":[],"artist":"Pedro Potier","artist_id":"7c79286c-7096-42b8-97e5-bbaa35ae241d","illustration_id":"98da4f1b-1b51-494c-9743-5e78b0802747","image_uris":{"small":"https://cards.scryfall.io/small/front/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.jpg?1679945549","normal":"https://cards.scryfall.io/normal/front/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.jpg?1679945549","large":"https://cards.scryfall.io/large/front/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.jpg?1679945549","png":"https://cards.scryfall.io/png/front/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.png?1679945549","art_crop":"https://cards.scryfall.io/art_crop/front/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.jpg?1679945549","border_crop":"https://cards.scryfall.io/border_crop/front/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.jpg?1679945549"}},{"object":"card_face","name":"Neera, Wild Mage","mana_cost":"","type_line":"Card","oracle_text":"","colors":[],"artist":"Pedro Potier","artist_id":"7c79286c-7096-42b8-97e5-bbaa35ae241d","illustration_id":"108a7d10-cf74-4cf1-a87e-cf9b0022ca92","image_uris":{"small":"https://cards.scryfall.io/small/back/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.jpg?1679945549","normal":"https://cards.scryfall.io/normal/back/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.jpg?1679945549","large":"https://cards.scryfall.io/large/back/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.jpg?1679945549","png":"https://cards.scryfall.io/png/back/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.png?1679945549","art_crop":"https://cards.scryfall.io/art_crop/back/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.jpg?1679945549","border_crop":"https://cards.scryfall.io/border_crop/back/8/4/84a051e5-df37-4020-971c-1dd1bb40d023.jpg?1679945549"}}],"legalities":{"standard":"not_legal","future":"not_legal","historic":"not_legal","timeless":"not_legal","gladiator":"not_legal","pioneer":"not_legal","explorer":"not_legal","modern":"not_legal","legacy":"not_legal","pauper":"not_legal","vintage":"not_legal","penny":"not_legal","commander":"not_legal","oathbreaker":"not_legal","standardbrawl":"not_legal","brawl":"not_legal","alchemy":"not_legal","paupercommander":"not_legal","duel":"not_legal","oldschool":"not_legal","premodern":"not_legal","predh":"not_legal"},"games":["paper"],"reserved":false,"foil":true,"nonfoil":true,"finishes":["nonfoil","foil"],"oversized":false,"promo":false,"reprint":false,"variation":false,"set_id":"5a1e41c1-05f4-4c73-9bc4-a2d7889ac3bb","set":"aclb","set_name":"Battle for Baldur's Gate Art Series","set_type":"memorabilia","set_uri":"https://api.scryfall.com/sets/5a1e41c1-05f4-4c73-9bc4-a2d7889ac3bb","set_search_uri":"https://api.scryfall.com/cards/search?order=set&q=e%3Aaclb&unique=prints","scryfall_set_uri":"https://scryfall.com/sets/aclb?utm_source=api","rulings_uri":"https://api.scryfall.com/cards/84a051e5-df37-4020-971c-1dd1bb40d023/rulings","prints_search_uri":"https://api.scryfall.com/cards/search?order=released&q=oracleid%3A403850c4-8f7f-47ec-8725-03ceee725f90&unique=prints","collector_number":"74","digital":false,"rarity":"common","artist":"Pedro Potier","artist_ids":["7c79286c-7096-42b8-97e5-bbaa35ae241d"],"border_color":"borderless","frame":"2015","full_art":false,"textless":false,"booster":false,"story_spotlight":false,"prices":{"usd":null,"usd_foil":null,"usd_etched":null,"eur":null,"eur_foil":null,"tix":null},"related_uris":{"tcgplayer_infinite_articles":"https://partner.tcgplayer.com/c/4931599/1830156/21018?subId1=api&trafcat=infinite&u=https%3A%2F%2Finfinite.tcgplayer.com%2Fsearch%3FcontentMode%3Darticle%26game%3Dmagic%26q%3DNeera%252C%2BWild%2BMage%2B%252F%252F%2BNeera%252C%2BWild%2BMage","tcgplayer_infinite_decks":"https://partner.tcgplayer.com/c/4931599/1830156/21018?subId1=api&trafcat=infinite&u=https%3A%2F%2Finfinite.tcgplayer.com%2Fsearch%3FcontentMode%3Ddeck%26game%3Dmagic%26q%3DNeera%252C%2BWild%2BMage%2B%252F%252F%2BNeera%252C%2BWild%2BMage","edhrec":"https://edhrec.com/route/?cc=Neera%2C+Wild+Mage"},"purchase_uris":{"tcgplayer":"https://partner.tcgplayer.com/c/4931599/1830156/21018?subId1=api&u=https%3A%2F%2Fwww.tcgplayer.com%2Fsearch%2Fmagic%2Fproduct%3FproductLineName%3Dmagic%26q%3DNeera%252C%2BWild%2BMage%26view%3Dgrid","cardmarket":"https://www.cardmarket.com/en/Magic/Products/Search?referrer=scryfall&searchString=Neera%2C+Wild+Mage&utm_campaign=card_prices&utm_medium=text&utm_source=scryfall","cardhoarder":"https://www.cardhoarder.com/cards?affiliate_id=scryfall&data%5Bsearch%5D=Neera%2C+Wild+Mage&ref=card-profile&utm_campaign=affiliate&utm_medium=card&utm_source=scryfall"}},

Other cards work however, such as:

    {
            "id": "22a6d05e-e566-4a85-bcf8-9d0fbea3dd14",
            "oracle_id": "c1ed20c0-f75d-4aca-8874-6955bd9fb21b",
            "name": "Kindled Heroism",
            "mana_cost": "{R}",
            "cmc": 1.0,
            "type_line": "Instant",
            "oracle_text": "Target creature gets +1/+0 and gains first strike until end of turn. Scry 1.",
            "power": null,
            "toughness": null,
            "colors": [
                "R"
            ],
            "color_identity": [
                "R"
            ],
            "set_code": "woe",
            "rarity": "common",
            "foil": true,
            "image_uris": {
                "art_crop": "https://cards.scryfall.io/art_crop/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.jpg?1692938335",
                "border_crop": "https://cards.scryfall.io/border_crop/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.jpg?1692938335",
                "large": "https://cards.scryfall.io/large/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.jpg?1692938335",
                "normal": "https://cards.scryfall.io/normal/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.jpg?1692938335",
                "png": "https://cards.scryfall.io/png/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.png?1692938335",
                "small": "https://cards.scryfall.io/small/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.jpg?1692938335"
            },
            "legalities": {
                "alchemy": "legal",
                "brawl": "legal",
                "commander": "legal",
                "duel": "legal",
                "explorer": "legal",
                "future": "legal",
                "gladiator": "legal",
                "historic": "legal",
                "legacy": "legal",
                "modern": "legal",
                "oathbreaker": "legal",
                "oldschool": "not_legal",
                "pauper": "legal",
                "paupercommander": "legal",
                "penny": "not_legal",
                "pioneer": "legal",
                "predh": "not_legal",
                "premodern": "not_legal",
                "standard": "legal",
                "standardbrawl": "legal",
                "timeless": "legal",
                "vintage": "legal"
            },
            "inserted_at": "2025-04-01T23:35:04",
            "updated_at": "2025-04-01T23:35:04"
        },

Which loads from:

{"object":"card","id":"22a6d05e-e566-4a85-bcf8-9d0fbea3dd14","oracle_id":"c1ed20c0-f75d-4aca-8874-6955bd9fb21b","multiverse_ids":[629639],"mtgo_id":116600,"arena_id":86838,"tcgplayer_id":513936,"cardmarket_id":729891,"name":"Kindled Heroism","lang":"en","released_at":"2023-09-08","uri":"https://api.scryfall.com/cards/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14","scryfall_uri":"https://scryfall.com/card/woe/138/kindled-heroism?utm_source=api","layout":"normal","highres_image":true,"image_status":"highres_scan","image_uris":{"small":"https://cards.scryfall.io/small/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.jpg?1692938335","normal":"https://cards.scryfall.io/normal/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.jpg?1692938335","large":"https://cards.scryfall.io/large/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.jpg?1692938335","png":"https://cards.scryfall.io/png/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.png?1692938335","art_crop":"https://cards.scryfall.io/art_crop/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.jpg?1692938335","border_crop":"https://cards.scryfall.io/border_crop/front/2/2/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14.jpg?1692938335"},"mana_cost":"{R}","cmc":1.0,"type_line":"Instant","oracle_text":"Target creature gets +1/+0 and gains first strike until end of turn. Scry 1.","colors":["R"],"color_identity":["R"],"keywords":["Scry"],"legalities":{"standard":"legal","future":"legal","historic":"legal","timeless":"legal","gladiator":"legal","pioneer":"legal","explorer":"legal","modern":"legal","legacy":"legal","pauper":"legal","vintage":"legal","penny":"not_legal","commander":"legal","oathbreaker":"legal","standardbrawl":"legal","brawl":"legal","alchemy":"legal","paupercommander":"legal","duel":"legal","oldschool":"not_legal","premodern":"not_legal","predh":"not_legal"},"games":["paper","arena","mtgo"],"reserved":false,"foil":true,"nonfoil":true,"finishes":["nonfoil","foil"],"oversized":false,"promo":false,"reprint":false,"variation":false,"set_id":"79139661-13ee-43c4-8bad-a8c069f1a1df","set":"woe","set_name":"Wilds of Eldraine","set_type":"expansion","set_uri":"https://api.scryfall.com/sets/79139661-13ee-43c4-8bad-a8c069f1a1df","set_search_uri":"https://api.scryfall.com/cards/search?order=set&q=e%3Awoe&unique=prints","scryfall_set_uri":"https://scryfall.com/sets/woe?utm_source=api","rulings_uri":"https://api.scryfall.com/cards/22a6d05e-e566-4a85-bcf8-9d0fbea3dd14/rulings","prints_search_uri":"https://api.scryfall.com/cards/search?order=released&q=oracleid%3Ac1ed20c0-f75d-4aca-8874-6955bd9fb21b&unique=prints","collector_number":"138","digital":false,"rarity":"common","flavor_text":"Even in the grip of Hylda's unnatural cold, something in Kellan felt bright as spring, something that poured into the empty hilts he'd been given by Talion and formed thorn-sharp blades of light.","card_back_id":"0aeebaf5-8c7d-4636-9e82-8c27447861f7","artist":"Leanna Crossan","artist_ids":["976cfe82-042e-4c2a-b762-2bc3e86cb6d0"],"illustration_id":"54e323d3-d12a-4bb5-b1d2-128477340243","border_color":"black","frame":"2015","full_art":false,"textless":false,"booster":true,"story_spotlight":true,"edhrec_rank":16799,"prices":{"usd":"0.06","usd_foil":"0.07","usd_etched":null,"eur":"0.06","eur_foil":"0.09","tix":"0.03"},"related_uris":{"gatherer":"https://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=629639&printed=false","tcgplayer_infinite_articles":"https://partner.tcgplayer.com/c/4931599/1830156/21018?subId1=api&trafcat=infinite&u=https%3A%2F%2Finfinite.tcgplayer.com%2Fsearch%3FcontentMode%3Darticle%26game%3Dmagic%26q%3DKindled%2BHeroism","tcgplayer_infinite_decks":"https://partner.tcgplayer.com/c/4931599/1830156/21018?subId1=api&trafcat=infinite&u=https%3A%2F%2Finfinite.tcgplayer.com%2Fsearch%3FcontentMode%3Ddeck%26game%3Dmagic%26q%3DKindled%2BHeroism","edhrec":"https://edhrec.com/route/?cc=Kindled+Heroism"},"purchase_uris":{"tcgplayer":"https://partner.tcgplayer.com/c/4931599/1830156/21018?subId1=api&u=https%3A%2F%2Fwww.tcgplayer.com%2Fproduct%2F513936%3Fpage%3D1","cardmarket":"https://www.cardmarket.com/en/Magic/Products/Singles/Wilds-of-Eldraine/Kindled-Heroism?referrer=scryfall&utm_campaign=card_prices&utm_medium=text&utm_source=scryfall","cardhoarder":"https://www.cardhoarder.com/cards/116600?affiliate_id=scryfall&ref=card-profile&utm_campaign=affiliate&utm_medium=card&utm_source=scryfall"}},


Analyze my code and determine why the former is loading as //, even when it's not necessarily a split card, and what I can do to fix the issue.
=== File: lib/mtg_draft_server/application.ex ===

defmodule MtgDraftServer.Application do
  use Application

  @impl true
  def start(_type, _args) do
    children = [
      MtgDraftServerWeb.Telemetry,
      MtgDraftServer.Repo,
      {DNSCluster, query: Application.get_env(:mtg_draft_server, :dns_cluster_query) || :ignore},
      {Phoenix.PubSub, name: MtgDraftServer.PubSub},
      {Finch, name: MtgDraftServer.Finch},
      MtgDraftServerWeb.Endpoint,
      {Registry, keys: :unique, name: MtgDraftServer.DraftRegistry},
      MtgDraftServer.DraftSessionSupervisor
    ]

    opts = [strategy: :one_for_one, name: MtgDraftServer.Supervisor]
    Supervisor.start_link(children, opts)
  end

  @impl true
  def config_change(changed, _new, removed) do
    MtgDraftServerWeb.Endpoint.config_change(changed, removed)
    :ok
  end
end

=== File: lib/mtg_draft_server/auth_error_handler.ex ===

defmodule MtgDraftServer.AuthErrorHandler do
  import Plug.Conn

  def auth_error(conn, {type, _reason}, _opts) do
    body = Jason.encode!(%{error: to_string(type)})

    conn
    |> put_resp_content_type("application/json")
    |> send_resp(401, body)
  end
end

=== File: lib/mtg_draft_server/cards/card.ex ===

defmodule MtgDraftServer.Cards.Card do
  @derive {Jason.Encoder,
           only: [
             :id,
             :oracle_id,
             :name,
             :mana_cost,
             :cmc,
             :type_line,
             :oracle_text,
             :power,
             :toughness,
             :colors,
             :color_identity,
             :set_code,
             :rarity,
             :foil,
             :image_uris,
             :legalities,
             :inserted_at,
             :updated_at
           ]}
  use Ecto.Schema
  import Ecto.Changeset

  # Ensures id is binary_id
  @primary_key {:id, :binary_id, autogenerate: true}
  # Ensures foreign keys also use binary_id
  @foreign_key_type :binary_id
  schema "cards" do
    field :oracle_id, Ecto.UUID
    field :name, :string
    field :mana_cost, :string
    field :cmc, :float
    field :type_line, :string
    field :oracle_text, :string
    field :power, :string
    field :toughness, :string
    field :colors, {:array, :string}
    field :color_identity, {:array, :string}
    field :set_code, :string
    field :rarity, :string
    field :foil, :boolean, default: false
    field :image_uris, :map
    field :legalities, :map

    timestamps()
  end

  @doc false
  def changeset(card, attrs) do
    card
    |> cast(attrs, [
      # Keep id here to allow it to be cast
      :id,
      :oracle_id,
      :name,
      :mana_cost,
      :cmc,
      :type_line,
      :oracle_text,
      :power,
      :toughness,
      :colors,
      :color_identity,
      :set_code,
      :rarity,
      :foil,
      :image_uris,
      :legalities
    ])
    |> validate_required([:oracle_id, :name, :set_code, :rarity])
  end
end

=== File: lib/mtg_draft_server/drafts/draft.ex ===

defmodule MtgDraftServer.Drafts.Draft do
  use Ecto.Schema
  import Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: true}
  schema "drafts" do
    field :status, :string, default: "pending"
    timestamps()
  end

  def changeset(draft, attrs) do
    draft
    |> cast(attrs, [:status])
    |> validate_required([:status])
  end
end

=== File: lib/mtg_draft_server/drafts/draft_pick.ex ===

defmodule MtgDraftServer.Drafts.DraftPick do
  use Ecto.Schema
  import Ecto.Changeset

  schema "draft_picks" do
    field :pack_number, :integer
    field :pick_number, :integer
    field :expires_at, :utc_datetime

    belongs_to :draft, MtgDraftServer.Drafts.Draft, type: :binary_id
    belongs_to :draft_player, MtgDraftServer.Drafts.DraftPlayer
    belongs_to :card, MtgDraftServer.Cards.Card, type: :binary_id

    timestamps()
  end

  def changeset(draft_pick, attrs) do
    draft_pick
    |> cast(attrs, [
      :draft_id,
      :draft_player_id,
      :card_id,
      :pack_number,
      :pick_number,
      :expires_at
    ])
    |> validate_required([
      :draft_id,
      :draft_player_id,
      :card_id,
      :pack_number,
      :pick_number,
      :expires_at
    ])
  end
end

=== File: lib/mtg_draft_server/drafts/draft_player.ex ===

defmodule MtgDraftServer.Drafts.DraftPlayer do
  use Ecto.Schema
  import Ecto.Changeset

  @derive {Jason.Encoder,
           only: [:id, :user_id, :seat, :connected, :draft_id, :inserted_at, :updated_at]}
  schema "draft_players" do
    field :user_id, :string
    field :seat, :integer
    field :connected, :boolean, default: true
    belongs_to :draft, MtgDraftServer.Drafts.Draft, type: :binary_id

    timestamps()
  end

  def changeset(draft_player, attrs) do
    draft_player
    |> cast(attrs, [:draft_id, :user_id, :seat, :connected])
    |> validate_required([:draft_id, :user_id, :seat])
  end

  def create_draft_player(attrs) do
    %__MODULE__{}
    |> changeset(attrs)
    |> MtgDraftServer.Repo.insert()
  end
end

=== File: lib/mtg_draft_server/drafts.ex ===

defmodule MtgDraftServer.Drafts do
  @moduledoc """
  Context for managing drafts, players, and picks.

  In this Magic: The Gathering draft server:
    - A draft is created independently of any player.
    - When a player creates a draft, a corresponding draft_player record is created.
    - A player may only be in one active (pending/active) draft at a time.
    - Each draft supports a maximum of 8 players.
  """

  import Ecto.Query, warn: false
  alias MtgDraftServer.Repo
  alias MtgDraftServer.Drafts.{Draft, DraftPlayer, DraftPick}

  @one_day_in_seconds 86400

  @type error :: {:error, Ecto.Changeset.t() | String.t()}
  @type draft_result :: {:ok, Draft.t()} | error
  @type pick_result :: {:ok, DraftPick.t()} | error
  @type player_result :: {:ok, DraftPlayer.t()} | error

  @doc """
  Creates a new draft.

  Note that the draft itself is agnostic of a player.
  If a creator is provided in the attrs (using key `:creator`), a corresponding
  draft_player record is created.
  """
  @spec create_draft(map()) :: draft_result
  def create_draft(attrs \\ %{}) do
    Repo.transaction(fn ->
      with {:ok, draft} <- do_create_draft(attrs),
           {:ok, _player} <- maybe_create_player(draft, attrs[:creator]) do
        draft
      else
        error -> Repo.rollback(error)
      end
    end)
  end

  @doc """
  Creates a new draft, starts its draft-session GenServer,
  and (if a creator is provided) joins the creator into the draft.

  Before creating a new draft, it ensures that the player isn’t already
  in an active (pending or active) draft.
  """
  @spec create_and_join_draft(map()) :: {:ok, Draft.t()} | {:error, any()}
  def create_and_join_draft(attrs \\ %{}) do
    if creator = attrs[:creator] do
      case get_active_draft_for_player(creator) do
        nil -> :ok
        _ -> {:error, "Player already in an active draft"}
      end
    else
      :ok
    end
    |> case do
      :ok ->
        Repo.transaction(fn ->
          with {:ok, draft} <- do_create_draft(attrs),
               {:ok, _player} <- maybe_create_player(draft, attrs[:creator]) do
            {:ok, _pid} = MtgDraftServer.DraftSessionSupervisor.start_new_session(draft.id)

            if attrs[:creator] do
              :ok =
                MtgDraftServer.DraftSession.join(draft.id, %{user_id: attrs[:creator], seat: 1})
            end

            draft
          else
            error -> Repo.rollback(error)
          end
        end)

      error ->
        error
    end
  end

  @doc """
  Retrieves the most recent active draft for a given player.
  (An active draft is one whose status is either "pending" or "active".)
  """
  @spec get_active_draft_for_player(String.t()) :: DraftPlayer.t() | nil
  def get_active_draft_for_player(user_id) do
    query =
      from dp in DraftPlayer,
        join: d in Draft,
        on: dp.draft_id == d.id,
        where: dp.user_id == ^user_id and d.status in ["pending", "active"],
        order_by: [desc: dp.inserted_at],
        limit: 1,
        preload: [:draft]

    Repo.one(query)
  end

  @doc """
  Starts a draft by updating its status to "active".
  Validates that the draft exists and has at least 2 players.
  """
  @spec start_draft(binary()) :: draft_result
  def start_draft(draft_id) do
    with {:ok, draft} <- get_draft(draft_id),
         :ok <- validate_draft_can_start(draft),
         {:ok, updated_draft} <- do_start_draft(draft) do
      broadcast_draft_update(draft_id, :draft_started)
      {:ok, updated_draft}
    end
  end

  @doc """
  Records a card pick in the draft.
  Validates that the pick is legal and updates the draft state accordingly.
  """
  def pick_card(draft_id, user_id, card_id, extra_attrs \\ %{}) do
    Repo.transaction(fn ->
      with {:ok, draft} <- get_draft(draft_id),
           :ok <- validate_draft_status(draft),
           {:ok, draft_player} <- get_draft_player(draft_id, user_id),
           :ok <- validate_player_turn(draft_id, user_id),
           :ok <- validate_card_availability(draft_id, card_id),
           :ok <- validate_pack_number(extra_attrs["pack_number"]),
           :ok <- validate_pick_number(extra_attrs["pick_number"]),
           :ok <-
             validate_no_duplicate_pick(
               draft_player.id,
               extra_attrs["pack_number"],
               extra_attrs["pick_number"]
             ) do
        now = DateTime.utc_now() |> DateTime.truncate(:second)
        expires_at = DateTime.add(now, @one_day_in_seconds, :second)

        attrs =
          Map.merge(extra_attrs, %{
            "draft_id" => draft_id,
            "draft_player_id" => draft_player.id,
            "card_id" => card_id,
            "expires_at" => expires_at
          })

        %DraftPick{}
        |> DraftPick.changeset(attrs)
        |> Repo.insert!()
      else
        error -> Repo.rollback(error)
      end
    end)
  end

  @doc """
  Retrieves all picks for a given draft and player.
  """
  @spec get_picked_cards(binary(), binary()) :: [DraftPick.t()]
  def get_picked_cards(draft_id, user_id) do
    with {:ok, draft_player} <- get_draft_player(draft_id, user_id) do
      query =
        from pick in DraftPick,
          where: pick.draft_player_id == ^draft_player.id,
          order_by: [asc: pick.inserted_at],
          preload: [:card]

      Repo.all(query)
    else
      _error -> []
    end
  end

  @doc """
  Gets a draft by its ID.
  Returns `{:ok, draft}` if found, or `{:error, "Draft not found"}` if not.
  """
  @spec get_draft(binary()) :: draft_result
  def get_draft(draft_id) do
    case Cachex.get(:draft_cache, "draft:#{draft_id}") do
      {:ok, draft} when not is_nil(draft) ->
        {:ok, draft}

      _ ->
        case Repo.get(Draft, draft_id) do
          nil ->
            {:error, "Draft not found"}

          draft ->
            Cachex.put(:draft_cache, "draft:#{draft_id}", draft, ttl: :timer.minutes(5))
            {:ok, draft}
        end
    end
  end

  @doc """
  Retrieves a draft player by draft ID and user ID.
  Returns `{:ok, draft_player}` if found, or `{:error, "Player not found in draft"}` if not.
  """
  def get_draft_player(draft_id, user_id) do
    case Repo.one(
           from dp in DraftPlayer,
             where: dp.draft_id == ^draft_id and dp.user_id == ^user_id,
             preload: [:draft]
         ) do
      nil -> {:error, "Player not found in draft"}
      player -> {:ok, player}
    end
  end

  @doc """
  Marks the draft as complete by updating its status.
  """
  @spec complete_draft(binary()) :: {:ok, Draft.t()} | {:error, any()}
  def complete_draft(draft_id) do
    with {:ok, draft} <- get_draft(draft_id) do
      draft
      |> Draft.changeset(%{status: "complete"})
      |> Repo.update()
    end
  end

  @doc """
  Returns a list of pending drafts that have fewer than 8 players.
  Each draft is returned as a map with keys: :id, :player_count, and :status.
  """
  def list_pending_drafts do
    query =
      from d in Draft,
        where: d.status == "pending",
        left_join: dp in DraftPlayer,
        on: dp.draft_id == d.id,
        group_by: d.id,
        having: count(dp.id) < 8,
        select: %{id: d.id, player_count: count(dp.id), status: d.status}

    Repo.all(query)
  end

  @doc """
  Joins the given user to the specified draft if it is not full.
  If the user is already in the draft, returns the existing record.
  """
  def join_draft(%Draft{} = draft, user_id) do
    case Repo.one(
           from dp in DraftPlayer,
             where: dp.draft_id == ^draft.id and dp.user_id == ^user_id
         ) do
      %DraftPlayer{} = existing_player ->
        {:ok, existing_player}

      nil ->
        player_count =
          Repo.one(from dp in DraftPlayer, where: dp.draft_id == ^draft.id, select: count(dp.id))

        if player_count < 8 do
          DraftPlayer.create_draft_player(%{
            draft_id: draft.id,
            user_id: user_id,
            seat: player_count + 1
          })
        else
          {:error, "Draft is full (max 8 players)"}
        end
    end
  end

  @doc """
  Returns a list of user IDs for all players in the specified draft.
  """
  def get_draft_players(draft_id) do
    from(dp in DraftPlayer, where: dp.draft_id == ^draft_id, select: dp.user_id)
    |> Repo.all()
  end

  # ============================================================================
  # Private functions
  # ============================================================================

  defp do_create_draft(attrs) do
    %Draft{}
    |> Draft.changeset(attrs)
    |> Repo.insert()
  end

  defp do_start_draft(draft) do
    draft
    |> Draft.changeset(%{status: "active"})
    |> Repo.update()
  end

  defp maybe_create_player(_draft, nil), do: {:ok, nil}

  defp maybe_create_player(draft, creator) do
    player_count =
      Repo.one(from dp in DraftPlayer, where: dp.draft_id == ^draft.id, select: count(dp.id))

    if player_count < 8 do
      DraftPlayer.create_draft_player(%{
        draft_id: draft.id,
        user_id: creator,
        seat: 1
      })
    else
      {:error, "Draft is full (max 8 players)"}
    end
  end

  # ============================================================================
  # Refactored Validation Functions
  # ============================================================================

  @doc """
  Validates whether it is the given user's turn to pick.

  Optionally, an existing state can be provided to avoid an extra GenServer call.
  """
  def validate_player_turn(draft_id, user_id, state \\ nil) do
    state =
      if state != nil do
        state
      else
        case Registry.lookup(MtgDraftServer.DraftRegistry, draft_id) do
          [{pid, _}] -> GenServer.call(pid, :get_state)
          [] -> nil
        end
      end

    if state == nil do
      {:error, "Draft session not found"}
    else
      do_validate_player_turn(user_id, state)
    end
  end

  defp do_validate_player_turn(user_id, state) do
    current_user = Enum.at(state.turn_order, state.current_turn_index)
    if current_user == user_id, do: :ok, else: {:error, "Not your turn to pick"}
  end

  @doc false
  def validate_card_availability(draft_id, card_id, state \\ nil) do
    state =
      if state != nil do
        state
      else
        case Registry.lookup(MtgDraftServer.DraftRegistry, draft_id) do
          [{pid, _}] -> GenServer.call(pid, :get_state)
          [] -> nil
        end
      end

    if state == nil do
      {:error, "Draft session not found"}
    else
      do_validate_card_availability(card_id, state)
    end
  end

  defp do_validate_card_availability(card_id, state) do
    current_user = Enum.at(state.turn_order, state.current_turn_index)

    cond do
      state.booster_packs ->
        current_pack = get_current_pack_for_player(state, current_user)

        if card_in_pack?(current_pack, card_id),
          do: :ok,
          else: {:error, "Card not available in current pack"}

      card_id in state.pack ->
        :ok

      true ->
        {:error, "Card not available in current pack"}
    end
  end

  defp get_current_pack_for_player(state, user_id) do
    player_packs = Map.get(state.booster_packs, user_id, [])
    Enum.at(player_packs, state.pack_number - 1, [])
  end

  defp card_in_pack?(pack, card_id) do
    Enum.any?(pack, fn card ->
      cond do
        is_map(card) && Map.has_key?(card, :id) -> card.id == card_id
        is_map(card) && Map.has_key?(card, "id") -> card["id"] == card_id
        true -> card == card_id
      end
    end)
  end

  defp validate_no_duplicate_pick(draft_player_id, pack_number, pick_number) do
    existing_pick =
      Repo.one(
        from p in DraftPick,
          where:
            p.draft_player_id == ^draft_player_id and
              p.pack_number == ^pack_number and
              p.pick_number == ^pick_number
      )

    if existing_pick do
      {:error, "Already made a pick for this pack/pick combination"}
    else
      :ok
    end
  end

  defp validate_draft_can_start(draft) do
    with :ok <- validate_draft_status(draft),
         :ok <- validate_player_count(draft) do
      :ok
    end
  end

  defp validate_draft_status(draft) do
    if draft.status == "pending" do
      :ok
    else
      {:error, "Draft cannot be started from #{draft.status} status"}
    end
  end

  defp validate_player_count(draft) do
    player_count =
      Repo.one(from dp in DraftPlayer, where: dp.draft_id == ^draft.id, select: count(dp.id))

    if player_count >= 2 do
      :ok
    else
      {:error, "Draft needs at least 2 players to start"}
    end
  end

  defp validate_pack_number(pack_number) when pack_number in 1..3, do: :ok
  defp validate_pack_number(_), do: {:error, "Invalid pack number"}

  defp validate_pick_number(pick_number) when pick_number in 1..15, do: :ok
  defp validate_pick_number(_), do: {:error, "Invalid pick number"}

  defp broadcast_draft_update(draft_id, event) do
    Phoenix.PubSub.broadcast(
      MtgDraftServer.PubSub,
      "draft:#{draft_id}",
      {event, draft_id}
    )
  end
end

=== File: lib/mtg_draft_server/draft_session.ex ===

defmodule MtgDraftServer.DraftSession do
  @moduledoc """
  A GenServer that represents a draft session and manages picking order.

  The session state includes:
    - the current (simulation) pack (a list of card IDs or card data) used before the draft starts
    - the turn order (a list of user IDs)
    - the current turn index
    - the pack number (1, 2, or 3) and pick number within the pack

  **New behavior:** When a player joins the session and the total number of players reaches 8, the draft
  automatically “starts” by generating 8×3 booster packs (24 packs total, each containing 15 cards)
  via the `MtgDraftServer.Drafts.PackGenerator`. The resulting booster pack distribution (a map of
  player ID to a list of 3 packs) is stored in the session state (in the `booster_packs` field) and a
  broadcast is issued to notify connected clients that the draft has started.
  """

  use GenServer
  alias MtgDraftServer.Drafts

  ## Client API

  def start_link(draft_id) do
    GenServer.start_link(__MODULE__, draft_id, name: via_tuple(draft_id))
  end

  def join(draft_id, player) do
    GenServer.call(via_tuple(draft_id), {:join, player})
  end

  def pick(draft_id, user_id, card_id) do
    GenServer.cast(via_tuple(draft_id), {:pick, user_id, card_id})
  end

  def get_state(draft_id) do
    GenServer.call(via_tuple(draft_id), :get_state)
  end

  defp via_tuple(draft_id) do
    {:via, Registry, {MtgDraftServer.DraftRegistry, draft_id}}
  end

  ## Server Callbacks

  @impl true
  def init(draft_id) do
    state = %{
      draft_id: draft_id,
      players: %{},
      turn_order: [],
      current_turn_index: 0,
      pack: [],
      pack_number: 1,
      pick_number: 1,
      status: :pending,
      booster_packs: nil,
      draft_started: false,
      current_pack_direction: :left
    }

    {:ok, state}
  end

  @impl true
  def handle_call({:join, player}, _from, state) do
    user_id = player["user_id"] || player[:user_id]
    new_players = Map.put(state.players, user_id, player)
    new_turn_order = state.turn_order ++ [user_id]
    new_state = %{state | players: new_players, turn_order: new_turn_order}

    if map_size(new_players) == 8 and not state.draft_started do
      booster_packs =
        MtgDraftServer.Drafts.PackGenerator.generate_and_distribute_booster_packs(
          %{},
          new_turn_order
        )

      updated_state =
        new_state
        |> Map.put(:booster_packs, booster_packs)
        |> Map.put(:draft_started, true)
        |> Map.put(:status, :active)
        |> Map.put(:current_pack_direction, :left)

      Phoenix.PubSub.broadcast(
        MtgDraftServer.PubSub,
        "draft:#{state.draft_id}",
        {:draft_started, updated_state.draft_id}
      )

      Drafts.start_draft(state.draft_id)

      {:reply, :ok, updated_state}
    else
      {:reply, :ok, new_state}
    end
  end

  @impl true
  def handle_call(:start_draft_with_boosters, _from, state) do
    if not state.draft_started and length(state.turn_order) >= 2 do
      booster_packs =
        MtgDraftServer.Drafts.PackGenerator.generate_and_distribute_booster_packs(
          %{},
          state.turn_order
        )

      updated_state =
        state
        |> Map.put(:booster_packs, booster_packs)
        |> Map.put(:draft_started, true)
        |> Map.put(:status, :active)
        |> Map.put(:current_pack_direction, :left)
        |> Map.put(:pack, [])

      Drafts.start_draft(state.draft_id)

      Phoenix.PubSub.broadcast(
        MtgDraftServer.PubSub,
        "draft:#{state.draft_id}",
        {:draft_started, updated_state.draft_id}
      )

      {:reply, {:ok, updated_state}, updated_state}
    else
      {:reply, {:error, "Cannot start draft"}, state}
    end
  end

  @impl true
  def handle_call(:get_state, _from, state) do
    {:reply, state, state}
  end

  @impl true
  def handle_cast({:pick, user_id, card_id}, state) do
    with :ok <- Drafts.validate_player_turn(state.draft_id, user_id, state),
         :ok <- Drafts.validate_card_availability(state.draft_id, card_id, state) do
      new_state = handle_real_booster_pick(state, user_id, card_id)
      {:noreply, new_state}
    else
      _error ->
        {:noreply, state}
    end
  end

  @impl true
  def handle_info({:ai_pick, user_id}, state) do
    if Enum.at(state.turn_order, state.current_turn_index) == user_id do
      if state.booster_packs do
        player_packs = Map.get(state.booster_packs, user_id, [])
        current_pack = Enum.at(player_packs, state.pack_number - 1, [])

        if current_pack != [] do
          random_card = Enum.random(current_pack)

          card_id =
            case random_card do
              %{id: id} -> id
              %{"id" => id} -> id
              simple_id when is_binary(simple_id) -> simple_id
              _ -> nil
            end

          if card_id do
            IO.puts("AI #{user_id} auto-picks card #{card_id}.")
            GenServer.cast(self(), {:pick, user_id, card_id})
          end
        end
      end
    end

    {:noreply, state}
  end

  # ============================================================================
  # Private functions
  # ============================================================================

  defp handle_real_booster_pick(state, user_id, card_id) do
    current_player_packs = Map.get(state.booster_packs, user_id, [])
    current_pack_index = state.pack_number - 1
    current_pack = Enum.at(current_player_packs, current_pack_index, [])

    picked_card =
      Enum.find(current_pack, fn card ->
        case card do
          %{id: id} -> id == card_id
          %{"id" => id} -> id == card_id
          _ -> false
        end
      end)

    if picked_card do
      _ =
        Drafts.pick_card(state.draft_id, user_id, card_id, %{
          "pack_number" => state.pack_number,
          "pick_number" => state.pick_number
        })

      updated_pack =
        Enum.reject(current_pack, fn card ->
          case card do
            %{id: id} -> id == card_id
            %{"id" => id} -> id == card_id
            _ -> false
          end
        end)

      updated_player_packs =
        List.replace_at(current_player_packs, current_pack_index, updated_pack)

      updated_booster_packs = Map.put(state.booster_packs, user_id, updated_player_packs)
      next_player_index = next_player_index(state)
      next_player = Enum.at(state.turn_order, next_player_index)

      cond do
        updated_pack != [] ->
          updated_booster_packs =
            pass_pack(
              updated_booster_packs,
              user_id,
              next_player,
              updated_pack,
              current_pack_index
            )

          updated_state = %{
            state
            | booster_packs: updated_booster_packs,
              current_turn_index: next_player_index,
              pick_number: state.pick_number + 1
          }

          Phoenix.PubSub.broadcast(
            MtgDraftServer.PubSub,
            "draft:#{state.draft_id}",
            {:pack_updated, next_player, state.pack_number, state.pick_number + 1}
          )

          maybe_schedule_ai(updated_state)
          updated_state

        current_pack_empty?(updated_booster_packs) and state.pack_number < 3 ->
          new_pack_number = state.pack_number + 1
          new_direction = if new_pack_number == 2, do: :right, else: :left

          updated_state = %{
            state
            | booster_packs: updated_booster_packs,
              pack_number: new_pack_number,
              pick_number: 1,
              current_turn_index: 0,
              current_pack_direction: new_direction
          }

          Phoenix.PubSub.broadcast(
            MtgDraftServer.PubSub,
            "draft:#{state.draft_id}",
            {:new_pack, new_pack_number}
          )

          maybe_schedule_ai(updated_state)
          updated_state

        current_pack_empty?(updated_booster_packs) and state.pack_number >= 3 ->
          # Final pack is empty; complete the draft.
          complete_draft(state)

        true ->
          updated_state = %{
            state
            | booster_packs: updated_booster_packs,
              current_turn_index: next_player_index
          }

          updated_state
      end
    else
      state
    end
  end

  defp pass_pack(booster_packs, _from_player, to_player, pack, pack_index) do
    to_player_packs = Map.get(booster_packs, to_player, [])

    updated_to_player_packs =
      if Enum.count(to_player_packs) > pack_index do
        List.replace_at(to_player_packs, pack_index, pack)
      else
        pad_list(to_player_packs, pack_index, []) ++ [pack]
      end

    Map.put(booster_packs, to_player, updated_to_player_packs)
  end

  defp pad_list(list, target_index, padding) do
    current_length = length(list)

    if current_length <= target_index do
      list ++ List.duplicate(padding, target_index - current_length)
    else
      list
    end
  end

  defp next_player_index(state) do
    player_count = length(state.turn_order)
    current_index = state.current_turn_index

    case state.current_pack_direction do
      :left ->
        rem(current_index + 1, player_count)

      :right ->
        rem(player_count + current_index - 1, player_count)
    end
  end

  defp current_pack_empty?(booster_packs) do
    Enum.all?(booster_packs, fn {_player_id, packs} ->
      current_pack = Enum.at(packs, 0, [])
      current_pack == []
    end)
  end

  defp maybe_schedule_ai(state) do
    next_player = Enum.at(state.turn_order, state.current_turn_index)
    next_player_info = Map.get(state.players, next_player, %{})

    if Map.get(next_player_info, "ai") || Map.get(next_player_info, :ai) do
      Process.send_after(self(), {:ai_pick, next_player}, 1_000)
    end
  end

  defp complete_draft(state) do
    Drafts.complete_draft(state.draft_id)

    Phoenix.PubSub.broadcast(
      MtgDraftServer.PubSub,
      "draft:#{state.draft_id}",
      {:draft_complete, state.draft_id}
    )

    %{state | status: :complete}
  end
end

=== File: lib/mtg_draft_server/draft_session_supervisor.ex ===

defmodule MtgDraftServer.DraftSessionSupervisor do
  use DynamicSupervisor

  def start_link(_args) do
    DynamicSupervisor.start_link(__MODULE__, :ok, name: __MODULE__)
  end

  @impl true
  def init(:ok) do
    DynamicSupervisor.init(strategy: :one_for_one)
  end

  @doc """
  Starts a new draft session.
  """
  def start_new_session(draft_id) do
    spec = {MtgDraftServer.DraftSession, draft_id}
    DynamicSupervisor.start_child(__MODULE__, spec)
  end
end

=== File: lib/mtg_draft_server/firebase_token.ex ===

defmodule MtgDraftServer.FirebaseToken do
  use Joken.Config

  @firebase_jwks_url "https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com"

  def verify_firebase_token(nil), do: {:error, :no_token_provided}

  def verify_firebase_token(token) do
    with {:ok, %{body: body}} <-
           Finch.build(:get, @firebase_jwks_url) |> Finch.request(MtgDraftServer.Finch),
         {:ok, certs} <- Jason.decode(body),
         {:ok, header} <- Joken.peek_header(token),
         %{"kid" => kid} = header,
         {:ok, jwk} <- get_jwk(certs, kid),
         {true, jose_jwt, _} <- JOSE.JWT.verify(jwk, token),
         {_, claims} <- JOSE.JWT.to_map(jose_jwt) do
      {:ok, claims}
    else
      {:error, _} = err -> err
      _ -> {:error, :invalid_token}
    end
  end

  defp get_jwk(%{"keys" => keys}, kid) do
    keys
    |> Enum.find(fn key -> key["kid"] == kid end)
    |> case do
      nil -> {:error, :invalid_kid}
      key -> {:ok, JOSE.JWK.from_map(key)}
    end
  end
end

=== File: lib/mtg_draft_server/jwks_strategy.ex ===

defmodule MtgDraftServer.JWKSStrategy do
  use JokenJwks.DefaultStrategyTemplate

  def init_opts(_) do
    [
      jwks_url:
        "https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com"
    ]
  end
end

=== File: lib/mtg_draft_server/pack_generator.ex ===

defmodule MtgDraftServer.Drafts.PackGenerator do
  @moduledoc """
  Generates booster packs for a draft based on the modern draft booster distribution.

  A modern draft booster (ignoring the marketing token) contains 15 Magic cards:
    - 1 Basic Land
    - 10 Common Cards
    - 3 Uncommon Cards
    - 1 Rare or Mythic Rare Card

  Additionally, there is a chance for one of the common cards to be replaced by a premium foil card
  (of any rarity). In that case the pack will have:
    - 1 Basic Land
    - 1 Foil Card
    - 9 Common Cards
    - 3 Uncommon Cards
    - 1 Rare or Mythic Rare Card

  Accepted options (opts):
    - :set_codes - a list of set codes (e.g. ["ulg", "m21"])
    - :allowed_rarities - a list of rarities to include (default: ["basic", "common", "uncommon", "rare", "mythic"])
    - :distribution - a map defining the default booster composition.
      Defaults to `%{"basic" => 1, "common" => 10, "uncommon" => 3, "rare" => 1}`.

  Additionally, packs can be distributed among players. For example, if a draft has 8 players,
  24 booster packs (8 × 3) will be generated and then grouped into three packs per player.
  """

  alias MtgDraftServer.Repo
  alias MtgDraftServer.Cards.Card
  import Ecto.Query

  @default_distribution %{"basic" => 1, "common" => 10, "uncommon" => 3, "rare" => 1}
  @foil_chance 0.25

  @doc """
  Prepares the booster pack card pool based on the provided options.

  This function:
    1. Parses the incoming options and fills in defaults.
    2. Queries the database for cards matching the provided set codes and allowed rarities.
    3. Groups the resulting cards by rarity.

  Returns a map with:
    - :opts - the parsed options
    - :rarity_groups - a map of rarity to a list of matching cards
  """
  def generate_booster_packs(opts \\ %{}) do
    parsed_opts = parse_opts(opts)
    cards = fetch_card_pool(parsed_opts)
    rarity_groups = group_cards_by_rarity(cards)
    %{opts: parsed_opts, rarity_groups: rarity_groups}
  end

  @doc """
  Generates a single booster pack using the given rarity groups and distribution.

  The process is as follows:
    1. Pick the required number of basic lands, commons, and uncommons.
    2. For the rare slot, combine the "rare" and "mythic" groups and pick one card.
    3. With a chance of #{@foil_chance * 100}%, select a foil card from all foil-eligible cards,
       remove one common card, and insert the foil.
    4. Shuffle the pack before returning it.

  Returns a list of cards representing the booster pack.
  """
  def generate_single_pack(rarity_groups, distribution) do
    basics = Enum.take_random(Map.get(rarity_groups, "basic", []), distribution["basic"])
    commons = Enum.take_random(Map.get(rarity_groups, "common", []), distribution["common"])
    uncommons = Enum.take_random(Map.get(rarity_groups, "uncommon", []), distribution["uncommon"])
    rare_pool = Map.get(rarity_groups, "rare", []) ++ Map.get(rarity_groups, "mythic", [])
    rare = Enum.take_random(rare_pool, distribution["rare"])

    initial_pack = basics ++ commons ++ uncommons ++ rare

    pack =
      if :rand.uniform() <= @foil_chance do
        case pick_foil_card(rarity_groups) do
          nil ->
            initial_pack

          foil_card ->
            if length(commons) > 0 do
              index = :rand.uniform(length(commons)) - 1
              new_commons = List.delete_at(commons, index)
              basics ++ new_commons ++ uncommons ++ rare ++ [foil_card]
            else
              initial_pack ++ [foil_card]
            end
        end
      else
        initial_pack
      end

    Enum.shuffle(pack)
  end

  @doc """
  Generates the specified number of booster packs using the provided rarity groups and distribution.

  By default, generates 24 packs (suitable for 8 players receiving 3 packs each).
  """
  def generate_all_packs(rarity_groups, distribution, num_packs \\ 24) do
    Enum.map(1..num_packs, fn _ -> generate_single_pack(rarity_groups, distribution) end)
  end

  @doc """
  Distributes booster packs to players.

  Given a list of players and a list of booster packs, groups the packs so that each player
  receives three packs. It assumes that length(packs) == length(players) * 3.

  Returns a map where keys are player identifiers (or player structs) and values are lists of packs.
  """
  def distribute_packs(packs, players) do
    packs_per_player = 3
    packs_chunks = Enum.chunk_every(packs, packs_per_player)

    Enum.zip(players, packs_chunks)
    |> Enum.into(%{})
  end

  @doc """
  Generates and distributes booster packs to the given players.

  * opts – options for pack generation (see generate_booster_packs/1)
  * players – a list of player identifiers (or player structs)

  Returns a map of player => list of booster packs.
  """
  def generate_and_distribute_booster_packs(opts \\ %{}, players) do
    %{opts: parsed_opts, rarity_groups: rarity_groups} = generate_booster_packs(opts)
    total_packs = length(players) * 3
    packs = generate_all_packs(rarity_groups, parsed_opts.distribution, total_packs)
    distribute_packs(packs, players)
  end

  # --- Private Helpers ---

  defp parse_opts(opts) do
    %{
      set_codes: Map.get(opts, :set_codes, []),
      allowed_rarities:
        Map.get(opts, :allowed_rarities, ["basic", "common", "uncommon", "rare", "mythic"]),
      distribution: Map.get(opts, :distribution, @default_distribution)
    }
  end

  defp fetch_card_pool(%{set_codes: set_codes, allowed_rarities: allowed_rarities}) do
    base_query =
      from card in Card,
        where: card.rarity in ^allowed_rarities

    query =
      if set_codes == [] do
        base_query
      else
        from card in base_query, where: card.set_code in ^set_codes
      end

    Repo.all(query)
  end

  defp group_cards_by_rarity(cards) do
    Enum.group_by(cards, & &1.rarity)
  end

  defp pick_foil_card(rarity_groups) do
    all_cards = Enum.flat_map(rarity_groups, fn {_rarity, cards} -> cards end)
    foil_pool = Enum.filter(all_cards, fn card -> card.foil end)

    case foil_pool do
      [] -> nil
      _ -> Enum.random(foil_pool)
    end
  end
end

=== File: lib/mtg_draft_server/repo.ex ===

defmodule MtgDraftServer.Repo do
  use Ecto.Repo,
    otp_app: :mtg_draft_server,
    adapter: Ecto.Adapters.Postgres
end

=== File: lib/mtg_draft_server.ex ===

defmodule MtgDraftServer do
  @moduledoc """
  MtgDraftServer keeps the contexts that define your domain
  and business logic.

  Contexts are also responsible for managing your data, regardless
  if it comes from the database, an external API or others.
  """
end

=== File: lib/mtg_draft_server_web/controllers/default_controller.ex ===

# lib/mtg_draft_server_web/controllers/default_controller.ex
defmodule MtgDraftServerWeb.DefaultController do
  use MtgDraftServerWeb, :controller

  def index(conn, _params) do
    json(conn, %{
      message: "Welcome to MTG Draft Server API",
      version: "1.0",
      endpoints: %{
        drafts: %{
          create: "POST /api/drafts",
          start: "POST /api/drafts/:id/start",
          pick: "POST /api/drafts/:id/pick",
          picked_cards: "GET /api/drafts/:id/picks"
        }
      }
    })
  end
end

=== File: lib/mtg_draft_server_web/controllers/draft_controller.ex ===

defmodule MtgDraftServerWeb.DraftController do
  use MtgDraftServerWeb, :controller

  alias MtgDraftServer.Drafts
  alias MtgDraftServer.DraftSession

  action_fallback MtgDraftServerWeb.FallbackController

  @doc """
  Create a new draft using the Firebase authenticated user.
  """
  def create(conn, _params) do
    case conn.assigns[:current_user] do
      %{"uid" => uid} ->
        with {:ok, draft} <- Drafts.create_and_join_draft(%{creator: uid}) do
          conn
          |> put_status(:created)
          |> put_resp_header("location", "/api/drafts/#{draft.id}")
          |> json(%{draft_id: draft.id, status: draft.status})
        end

      _ ->
        conn
        |> put_status(:unauthorized)
        |> json(%{"error" => "Authentication required"})
    end
  end

  @doc """
  Start the draft by updating its status to "active".
  """
  def start(conn, %{"id" => draft_id}) do
    case conn.assigns[:current_user] do
      %{"uid" => uid} ->
        with {:ok, draft} <- Drafts.get_draft(draft_id),
             {:ok, _authorized} <- authorize_draft_action(draft, uid) do
          # Call the draft session to start with booster packs
          case Registry.lookup(MtgDraftServer.DraftRegistry, draft_id) do
            [{pid, _}] ->
              case GenServer.call(pid, :start_draft_with_boosters) do
                {:ok, _state} ->
                  json(conn, %{
                    draft_id: draft_id,
                    status: "active",
                    message: "Draft started with booster packs"
                  })

                {:error, reason} ->
                  conn |> put_status(:bad_request) |> json(%{error: reason})
              end

            [] ->
              # Start a new session if one doesn't exist
              {:ok, pid} = MtgDraftServer.DraftSessionSupervisor.start_new_session(draft_id)

              case GenServer.call(pid, :start_draft_with_boosters) do
                {:ok, _state} ->
                  json(conn, %{
                    draft_id: draft_id,
                    status: "active",
                    message: "Draft started with booster packs"
                  })

                {:error, reason} ->
                  conn |> put_status(:bad_request) |> json(%{error: reason})
              end
          end
        end

      _ ->
        conn |> put_status(:unauthorized) |> json(%{"error" => "Authentication required"})
    end
  end

  @doc """
  Persist a card pick.
  """
  def pick(conn, %{"id" => draft_id, "card_id" => card_id}) do
    case conn.assigns[:current_user] do
      %{"uid" => uid} ->
        with {:ok, _} <- ensure_in_draft_session(draft_id, uid),
             {:ok, draft} <- Drafts.get_draft(draft_id),
             {:ok, _authorized} <- authorize_draft_action(draft, uid) do
          # Delegate the pick to the DraftSession.
          DraftSession.pick(draft_id, uid, card_id)
          json(conn, %{message: "Pick registered"})
        end

      _ ->
        conn
        |> put_status(:unauthorized)
        |> json(%{"error" => "Authentication required"})
    end
  end

  @doc """
  Get all picks for the current user in a given draft.
  """
  def picked_cards(conn, %{"id" => draft_id}) do
    case conn.assigns[:current_user] do
      %{"uid" => uid} ->
        with {:ok, draft} <- Drafts.get_draft(draft_id),
             {:ok, _authorized} <- authorize_draft_action(draft, uid) do
          picks = Drafts.get_picked_cards(draft_id, uid)
          json(conn, %{picks: picks})
        end

      _ ->
        conn
        |> put_status(:unauthorized)
        |> json(%{"error" => "Authentication required"})
    end
  end

  @doc """
  Generate booster packs and distribute them among players.
  """
  def generate_booster_packs(conn, params) do
    players = Map.get(params, "players", [])

    opts = %{
      set_codes: Map.get(params, "set_codes", []),
      allowed_rarities:
        Map.get(params, "allowed_rarities", ["basic", "common", "uncommon", "rare", "mythic"]),
      distribution:
        Map.get(params, "distribution", %{
          "basic" => 1,
          "common" => 10,
          "uncommon" => 3,
          "rare" => 1
        })
    }

    packs_distribution = Drafts.PackGenerator.generate_and_distribute_booster_packs(opts, players)
    json(conn, packs_distribution)
  end

  @doc """
  Add an AI player to an active draft.

  Expects JSON with:
    - "id": the draft id
    - "ai_id": a unique identifier for the AI (e.g. "AI_1")
  """
  def add_ai(conn, %{"id" => draft_id, "ai_id" => ai_id}) do
    case conn.assigns[:current_user] do
      %{"uid" => _uid} ->
        :ok = DraftSession.join(draft_id, %{"user_id" => ai_id, "ai" => true})
        json(conn, %{message: "AI player #{ai_id} added to draft", draft_id: draft_id})

      _ ->
        conn
        |> put_status(:unauthorized)
        |> json(%{"error" => "Authentication required"})
    end
  end

  @doc """
  Lists pending drafts (those in "pending" status with fewer than 8 players).
  """
  def pending_drafts(conn, _params) do
    drafts = Drafts.list_pending_drafts()
    json(conn, %{drafts: drafts})
  end

  @doc """
  Allows a user to join an existing pending draft.
  """
  def join(conn, %{"id" => draft_id}) do
    case conn.assigns[:current_user] do
      %{"uid" => uid} ->
        with {:ok, draft} <- Drafts.get_draft(draft_id),
             {:ok, player} <- Drafts.join_draft(draft, uid) do
          # Check if draft session exists, start it if it doesn't
          case Registry.lookup(MtgDraftServer.DraftRegistry, draft_id) do
            [] ->
              # Session doesn't exist, start a new one
              {:ok, _pid} = MtgDraftServer.DraftSessionSupervisor.start_new_session(draft_id)
              :ok = DraftSession.join(draft_id, %{"user_id" => uid})

            [{_pid, _}] ->
              # Session exists, join it
              :ok = DraftSession.join(draft_id, %{"user_id" => uid})
          end

          json(conn, %{draft_id: draft.id, message: "Joined draft", player: player})
        else
          error -> conn |> put_status(:bad_request) |> json(%{error: error})
        end

      _ ->
        conn
        |> put_status(:unauthorized)
        |> json(%{error: "Authentication required"})
    end
  end

  @doc """
  Get the current state of the draft, including if it's the user's turn and the current pack if applicable.
  """
  def state(conn, %{"id" => draft_id}) do
    case conn.assigns[:current_user] do
      %{"uid" => uid} ->
        with {:ok, draft} <- Drafts.get_draft(draft_id),
             {:ok, _authorized} <- authorize_draft_action(draft, uid) do
          # Get draft session state
          case Registry.lookup(MtgDraftServer.DraftRegistry, draft_id) do
            [{pid, _}] ->
              state = GenServer.call(pid, :get_state)
              current_user_index = Enum.find_index(state.turn_order, fn id -> id == uid end)
              is_your_turn = state.current_turn_index == current_user_index

              # Only include current pack if it's the user's turn
              current_pack =
                if is_your_turn do
                  get_current_pack_for_user(state, uid)
                else
                  []
                end

              json(conn, %{
                status: state.status,
                pack_number: state.pack_number,
                pick_number: state.pick_number,
                is_your_turn: is_your_turn,
                current_pack: current_pack
              })

            [] ->
              conn
              |> put_status(:not_found)
              |> json(%{error: "Draft session not found"})
          end
        end

      _ ->
        conn
        |> put_status(:unauthorized)
        |> json(%{error: "Authentication required"})
    end
  end

  @doc """
  Reconnects the user to their active draft and returns lobby state.
  """
  def reconnect(conn, _params) do
    case conn.assigns[:current_user] do
      %{"uid" => uid} ->
        case Drafts.get_active_draft_for_player(uid) do
          nil ->
            conn
            |> put_status(:not_found)
            |> json(%{error: "No active draft found for user"})

          draft_player ->
            draft_id = draft_player.draft.id

            case Registry.lookup(MtgDraftServer.DraftRegistry, draft_id) do
              [{_pid, _}] ->
                :ok = DraftSession.join(draft_id, %{"user_id" => uid})
                players = Drafts.get_draft_players(draft_id)
                json(conn, %{message: "Rejoined draft", draft_id: draft_id, players: players})

              [] ->
                {:ok, _pid} = MtgDraftServer.DraftSessionSupervisor.start_new_session(draft_id)
                :ok = DraftSession.join(draft_id, %{"user_id" => uid})
                players = Drafts.get_draft_players(draft_id)

                json(conn, %{
                  message: "Draft session restarted and rejoined",
                  draft_id: draft_id,
                  players: players
                })
            end
        end

      _ ->
        conn
        |> put_status(:unauthorized)
        |> json(%{"error" => "Authentication required"})
    end
  end

  # --------------------
  # Helper Functions
  # --------------------

  defp ensure_in_draft_session(draft_id, user_id) do
    :ok = DraftSession.join(draft_id, %{"user_id" => user_id})
    {:ok, :joined}
  end

  defp authorize_draft_action(draft, user_id) do
    case Drafts.get_draft_player(draft.id, user_id) do
      {:ok, _player} -> {:ok, true}
      _ -> {:error, "Unauthorized"}
    end
  end

  defp get_current_pack_for_user(state, user_id) do
    if state.booster_packs do
      # Get the player's packs
      player_packs = Map.get(state.booster_packs, user_id, [])
      # Get the current pack based on pack_number (1-indexed, so subtract 1)
      current_pack = Enum.at(player_packs, state.pack_number - 1, [])
      current_pack
    else
      []
    end
  end
end

=== File: lib/mtg_draft_server_web/controllers/error_json.ex ===

defmodule MtgDraftServerWeb.ErrorJSON do
  @moduledoc """
  This module is invoked by your endpoint in case of errors on JSON requests.

  See config/config.exs.
  """

  # If you want to customize a particular status code,
  # you may add your own clauses, such as:
  #
  # def render("500.json", _assigns) do
  #   %{errors: %{detail: "Internal Server Error"}}
  # end

  # By default, Phoenix returns the status message from
  # the template name. For example, "404.json" becomes
  # "Not Found".
  def render(template, _assigns) do
    %{errors: %{detail: Phoenix.Controller.status_message_from_template(template)}}
  end
end

=== File: lib/mtg_draft_server_web/controllers/fallback_controller.ex ===

defmodule MtgDraftServerWeb.FallbackController do
  use MtgDraftServerWeb, :controller

  # For Ecto errors, you might pattern match like this:
  def call(conn, {:error, %Ecto.Changeset{} = changeset}) do
    conn
    |> put_status(:unprocessable_entity)
    |> json(%{errors: changeset})
  end

  def call(conn, {:error, message}) when is_binary(message) do
    conn
    |> put_status(:bad_request)
    |> json(%{error: message})
  end
end

=== File: lib/mtg_draft_server_web/endpoint.ex ===

defmodule MtgDraftServerWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :mtg_draft_server

  # Force SSL in production if configured
  if Application.compile_env(:mtg_draft_server, :force_ssl, false) do
    plug Plug.SSL, rewrite_on: [:x_forwarded_proto]
  end

  # The session will be stored in the cookie and signed,
  # this means its contents can be read but not tampered with.
  # Set :encryption_salt if you would also like to encrypt it.
  @session_options [
    store: :cookie,
    key: "_mtg_draft_server_key",
    signing_salt: "WOTNq3DB",
    same_site: "Lax"
  ]

  # socket "/live", Phoenix.LiveView.Socket,
  #   websocket: [connect_info: [session: @session_options]],
  #   longpoll: [connect_info: [session: @session_options]]

  # Serve at "/" the static files from "priv/static" directory.
  #
  # You should set gzip to true if you are running phx.digest
  # when deploying your static files in production.
  plug Plug.Static,
    at: "/",
    from: :mtg_draft_server,
    gzip: false,
    only: MtgDraftServerWeb.static_paths()

  # Code reloading can be explicitly enabled under the
  # :code_reloader configuration of your endpoint.
  if code_reloading? do
    plug Phoenix.CodeReloader
    plug Phoenix.Ecto.CheckRepoStatus, otp_app: :mtg_draft_server
  end

  plug Plug.RequestId
  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

  plug Plug.Parsers,
    parsers: [:urlencoded, :multipart, :json],
    pass: ["*/*"],
    json_decoder: Phoenix.json_library()

  plug Plug.MethodOverride
  plug Plug.Head
  plug Plug.Session, @session_options

  plug CORSPlug,
    origin: ["http://localhost:5173"],
    methods: ["GET", "POST"],
    headers: ["Authorization", "Content-Type", "Accept"],
    expose: ["Authorization"],
    credentials: true,
    max_age: 86400

  plug MtgDraftServerWeb.Router
end

=== File: lib/mtg_draft_server_web/gettext.ex ===

defmodule MtgDraftServerWeb.Gettext do
  @moduledoc """
  A module providing Internationalization with a gettext-based API.

  By using [Gettext](https://hexdocs.pm/gettext),
  your module gains a set of macros for translations, for example:

      import MtgDraftServerWeb.Gettext

      # Simple translation
      gettext("Here is the string to translate")

      # Plural translation
      ngettext("Here is the string to translate",
               "Here are the strings to translate",
               3)

      # Domain-based translation
      dgettext("errors", "Here is the error message to translate")

  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.
  """
  use Gettext.Backend, otp_app: :mtg_draft_server
end

=== File: lib/mtg_draft_server_web/plugs/auth_plug.ex ===

defmodule MtgDraftServerWeb.AuthPlug do
  import Plug.Conn
  alias MtgDraftServer.FirebaseToken

  def init(default), do: default

  def call(conn, _opts) do
    if Application.get_env(:mtg_draft_server, :skip_auth, false) do
      # In test (or any env where :skip_auth is true), bypass real auth
      assign(conn, :current_user, %{"uid" => "test_user"})
    else
      case get_req_header(conn, "authorization") do
        ["Bearer " <> token] ->
          verify_token(conn, token)

        _ ->
          conn
          |> send_resp(401, Jason.encode!(%{error: "Missing or invalid Authorization header"}))
          |> halt()
      end
    end
  end

  defp verify_token(conn, token) do
    case FirebaseToken.verify_firebase_token(token) do
      {:ok, claims} ->
        IO.inspect(claims, label: "✅ Firebase Token Claims")
        # Map "user_id" to "uid" so controllers can consistently use "uid"
        claims = Map.put(claims, "uid", claims["user_id"])
        assign(conn, :current_user, claims)

      {:error, reason} ->
        IO.inspect(reason, label: "❌ Token Verification Failed")

        conn
        |> send_resp(401, Jason.encode!(%{error: "Invalid token"}))
        |> halt()
    end
  end
end

=== File: lib/mtg_draft_server_web/router.ex ===

defmodule MtgDraftServerWeb.Router do
  use MtgDraftServerWeb, :router

  alias MtgDraftServerWeb.AuthPlug

  pipeline :api do
    plug :accepts, ["json"]
  end

  pipeline :auth_api do
    plug :accepts, ["json"]
    plug AuthPlug
  end

  scope "/", MtgDraftServerWeb do
    pipe_through :api
    get "/", DefaultController, :index
  end

  scope "/api", MtgDraftServerWeb, as: :api do
    pipe_through :auth_api

    get "/drafts/:id/state", DraftController, :state
    get "/drafts/pending", DraftController, :pending_drafts
    get "/drafts/:id/picks", DraftController, :picked_cards

    post "/drafts", DraftController, :create
    post "/drafts/:id/start", DraftController, :start
    post "/drafts/:id/start_with_boosters", DraftController, :start_draft_with_boosters
    post "/drafts/:id/pick", DraftController, :pick
    post "/drafts/reconnect", DraftController, :reconnect
    post "/drafts/booster_packs", DraftController, :generate_booster_packs
    post "/drafts/:id/add_ai", DraftController, :add_ai
    post "/drafts/:id/join", DraftController, :join
  end
end

=== File: lib/mtg_draft_server_web/telemetry.ex ===

defmodule MtgDraftServerWeb.Telemetry do
  use Supervisor
  import Telemetry.Metrics

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  @impl true
  def init(_arg) do
    children = [
      # Telemetry poller will execute the given period measurements
      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics
      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}
      # Add reporters as children of your supervision tree.
      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end

  def metrics do
    [
      # Phoenix Metrics
      summary("phoenix.endpoint.start.system_time",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.endpoint.stop.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.start.system_time",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.exception.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.stop.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.socket_connected.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.channel_joined.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.channel_handled_in.duration",
        tags: [:event],
        unit: {:native, :millisecond}
      ),

      # Database Metrics
      summary("mtg_draft_server.repo.query.total_time",
        unit: {:native, :millisecond},
        description: "The sum of the other measurements"
      ),
      summary("mtg_draft_server.repo.query.decode_time",
        unit: {:native, :millisecond},
        description: "The time spent decoding the data received from the database"
      ),
      summary("mtg_draft_server.repo.query.query_time",
        unit: {:native, :millisecond},
        description: "The time spent executing the query"
      ),
      summary("mtg_draft_server.repo.query.queue_time",
        unit: {:native, :millisecond},
        description: "The time spent waiting for a database connection"
      ),
      summary("mtg_draft_server.repo.query.idle_time",
        unit: {:native, :millisecond},
        description:
          "The time the connection spent waiting before being checked out for the query"
      ),

      # VM Metrics
      summary("vm.memory.total", unit: {:byte, :kilobyte}),
      summary("vm.total_run_queue_lengths.total"),
      summary("vm.total_run_queue_lengths.cpu"),
      summary("vm.total_run_queue_lengths.io")
    ]
  end

  defp periodic_measurements do
    [
      # A module, function and arguments to be invoked periodically.
      # This function must call :telemetry.execute/3 and a metric must be added above.
      # {MtgDraftServerWeb, :count_users, []}
    ]
  end
end

=== File: lib/mtg_draft_server_web.ex ===

defmodule MtgDraftServerWeb do
  @moduledoc """
  The entrypoint for defining your web interface, such
  as controllers, components, channels, and so on.

  This can be used in your application as:

      use MtgDraftServerWeb, :controller
      use MtgDraftServerWeb, :html

  The definitions below will be executed for every controller,
  component, etc, so keep them short and clean, focused
  on imports, uses and aliases.

  Do NOT define functions inside the quoted expressions
  below. Instead, define additional modules and import
  those modules here.
  """

  def static_paths, do: ~w(assets fonts images favicon.ico robots.txt)

  def router do
    quote do
      use Phoenix.Router
      import Plug.Conn
      import Phoenix.Controller
    end
  end

  def channel do
    quote do
      use Phoenix.Channel
    end
  end

  def controller do
    quote do
      use Phoenix.Controller,
        formats: [:html, :json],
        layouts: [html: MtgDraftServerWeb.Layouts]

      import Plug.Conn
      import MtgDraftServerWeb.Gettext

      unquote(verified_routes())
    end
  end

  def verified_routes do
    quote do
      use Phoenix.VerifiedRoutes,
        endpoint: MtgDraftServerWeb.Endpoint,
        router: MtgDraftServerWeb.Router,
        statics: MtgDraftServerWeb.static_paths()
    end
  end

  @doc """
  When used, dispatch to the appropriate controller/live_view/etc.
  """
  defmacro __using__(which) when is_atom(which) do
    apply(__MODULE__, which, [])
  end
end

=== File: mix.exs ===

defmodule MtgDraftServer.MixProject do
  use Mix.Project

  def project do
    [
      app: :mtg_draft_server,
      version: "0.1.0",
      elixir: "~> 1.14",
      elixirc_paths: elixirc_paths(Mix.env()),
      start_permanent: Mix.env() == :prod,
      aliases: aliases(),
      deps: deps()
    ]
  end

  # Configuration for the OTP application.
  #
  # Type `mix help compile.app` for more information.
  def application do
    [
      mod: {MtgDraftServer.Application, []},
      extra_applications: [:logger, :runtime_tools]
    ]
  end

  # Specifies which paths to compile per environment.
  defp elixirc_paths(:test), do: ["lib", "test/support"]
  defp elixirc_paths(_), do: ["lib"]

  # Specifies your project dependencies.
  #
  # Type `mix help deps` for examples and options.
  defp deps do
    [
      {:phoenix, "~> 1.7.14"},
      {:phoenix_ecto, "~> 4.5"},
      {:ecto_sql, "~> 3.10"},
      {:postgrex, ">= 0.0.0"},
      {:swoosh, "~> 1.5"},
      {:finch, "~> 0.13"},
      {:telemetry_metrics, "~> 1.0"},
      {:telemetry_poller, "~> 1.0"},
      {:gettext, "~> 0.20"},
      {:jason, "~> 1.2"},
      {:dns_cluster, "~> 0.1.1"},
      {:bandit, "~> 1.5"},
      {:cachex, "~> 3.6"},
      {:cors_plug, "~> 3.0"},
      {:joken, "~> 2.5"},
      {:joken_jwks, "~> 1.6"}
    ]
  end

  # Aliases are shortcuts or tasks specific to the current project.
  # For example, to install project dependencies and perform other setup tasks, run:
  #
  #     $ mix setup
  #
  # See the documentation for `Mix` for more info on aliases.
  defp aliases do
    [
      setup: ["deps.get", "ecto.setup"],
      "ecto.setup": ["ecto.create", "ecto.migrate", "run priv/repo/seeds.exs"],
      "ecto.reset": ["ecto.drop", "ecto.setup"],
      test: ["ecto.create --quiet", "ecto.migrate --quiet", "test"]
    ]
  end
end

=== File: priv/gettext/en/LC_MESSAGES/errors.po ===

## `msgid`s in this file come from POT (.pot) files.
##
## Do not add, change, or remove `msgid`s manually here as
## they're tied to the ones in the corresponding POT file
## (with the same domain).
##
## Use `mix gettext.extract --merge` or `mix gettext.merge`
## to merge POT files into PO files.
msgid ""
msgstr ""
"Language: en\n"

## From Ecto.Changeset.cast/4
msgid "can't be blank"
msgstr ""

## From Ecto.Changeset.unique_constraint/3
msgid "has already been taken"
msgstr ""

## From Ecto.Changeset.put_change/3
msgid "is invalid"
msgstr ""

## From Ecto.Changeset.validate_acceptance/3
msgid "must be accepted"
msgstr ""

## From Ecto.Changeset.validate_format/3
msgid "has invalid format"
msgstr ""

## From Ecto.Changeset.validate_subset/3
msgid "has an invalid entry"
msgstr ""

## From Ecto.Changeset.validate_exclusion/3
msgid "is reserved"
msgstr ""

## From Ecto.Changeset.validate_confirmation/3
msgid "does not match confirmation"
msgstr ""

## From Ecto.Changeset.no_assoc_constraint/3
msgid "is still associated with this entry"
msgstr ""

msgid "are still associated with this entry"
msgstr ""

## From Ecto.Changeset.validate_length/3
msgid "should have %{count} item(s)"
msgid_plural "should have %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} character(s)"
msgid_plural "should be %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} byte(s)"
msgid_plural "should be %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at least %{count} item(s)"
msgid_plural "should have at least %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} character(s)"
msgid_plural "should be at least %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} byte(s)"
msgid_plural "should be at least %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at most %{count} item(s)"
msgid_plural "should have at most %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} character(s)"
msgid_plural "should be at most %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} byte(s)"
msgid_plural "should be at most %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

## From Ecto.Changeset.validate_number/3
msgid "must be less than %{number}"
msgstr ""

msgid "must be greater than %{number}"
msgstr ""

msgid "must be less than or equal to %{number}"
msgstr ""

msgid "must be greater than or equal to %{number}"
msgstr ""

msgid "must be equal to %{number}"
msgstr ""

=== File: priv/gettext/errors.pot ===

## This is a PO Template file.
##
## `msgid`s here are often extracted from source code.
## Add new translations manually only if they're dynamic
## translations that can't be statically extracted.
##
## Run `mix gettext.extract` to bring this file up to
## date. Leave `msgstr`s empty as changing them here has no
## effect: edit them in PO (`.po`) files instead.
## From Ecto.Changeset.cast/4
msgid "can't be blank"
msgstr ""

## From Ecto.Changeset.unique_constraint/3
msgid "has already been taken"
msgstr ""

## From Ecto.Changeset.put_change/3
msgid "is invalid"
msgstr ""

## From Ecto.Changeset.validate_acceptance/3
msgid "must be accepted"
msgstr ""

## From Ecto.Changeset.validate_format/3
msgid "has invalid format"
msgstr ""

## From Ecto.Changeset.validate_subset/3
msgid "has an invalid entry"
msgstr ""

## From Ecto.Changeset.validate_exclusion/3
msgid "is reserved"
msgstr ""

## From Ecto.Changeset.validate_confirmation/3
msgid "does not match confirmation"
msgstr ""

## From Ecto.Changeset.no_assoc_constraint/3
msgid "is still associated with this entry"
msgstr ""

msgid "are still associated with this entry"
msgstr ""

## From Ecto.Changeset.validate_length/3
msgid "should have %{count} item(s)"
msgid_plural "should have %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} character(s)"
msgid_plural "should be %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} byte(s)"
msgid_plural "should be %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at least %{count} item(s)"
msgid_plural "should have at least %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} character(s)"
msgid_plural "should be at least %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} byte(s)"
msgid_plural "should be at least %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at most %{count} item(s)"
msgid_plural "should have at most %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} character(s)"
msgid_plural "should be at most %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} byte(s)"
msgid_plural "should be at most %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

## From Ecto.Changeset.validate_number/3
msgid "must be less than %{number}"
msgstr ""

msgid "must be greater than %{number}"
msgstr ""

msgid "must be less than or equal to %{number}"
msgstr ""

msgid "must be greater than or equal to %{number}"
msgstr ""

msgid "must be equal to %{number}"
msgstr ""

=== File: priv/repo/migrations/.formatter.exs ===

[
  import_deps: [:ecto_sql],
  inputs: ["*.exs"]
]

=== File: priv/repo/migrations/20250208230004_create_cards.exs ===

defmodule MtgDraftServer.Repo.Migrations.CreateCards do
  use Ecto.Migration

  def change do
    create table(:cards, primary_key: false) do
      add :id, :uuid, primary_key: true
      add :oracle_id, :uuid, null: false
      add :name, :string, null: false
      add :mana_cost, :string
      add :cmc, :float
      add :type_line, :string
      add :oracle_text, :text
      add :power, :string
      add :toughness, :string
      add :colors, {:array, :string}
      add :color_identity, {:array, :string}

      # NEW FIELDS FOR BOOSTER GENERATION
      add :set_code, :string, null: false
      add :rarity, :string
      add :foil, :boolean, default: false

      add :image_uris, :map
      add :legalities, :map

      timestamps()
    end

    create unique_index(:cards, [:oracle_id])
    create unique_index(:cards, [:name])
  end
end

=== File: priv/repo/migrations/20250209005129_create_drafts.exs ===

defmodule MtgDraftServer.Repo.Migrations.CreateDrafts do
  use Ecto.Migration

  def change do
    create table(:drafts, primary_key: false) do
      add :id, :uuid, primary_key: true
      # Use a string status (e.g., "pending", "active", "complete")
      add :status, :string, default: "pending"
      timestamps()
    end
  end
end

=== File: priv/repo/migrations/20250209005146_create_draft_players.exs ===

defmodule MtgDraftServer.Repo.Migrations.CreateDraftPlayers do
  use Ecto.Migration

  def change do
    create table(:draft_players) do
      add :draft_id, references(:drafts, type: :uuid, on_delete: :delete_all), null: false
      # Storing the Firebase UID (or any user identifier) as a string:
      add :user_id, :string, null: false
      add :seat, :integer, null: false
      # Optionally track connection status for handling disconnects:
      add :connected, :boolean, default: true

      timestamps()
    end

    create index(:draft_players, [:draft_id])
    create unique_index(:draft_players, [:draft_id, :user_id])
  end
end

=== File: priv/repo/migrations/20250209005217_create_draft_picks.exs ===

defmodule MtgDraftServer.Repo.Migrations.CreateDraftPicks do
  use Ecto.Migration

  def change do
    create table(:draft_picks) do
      add :draft_id, references(:drafts, type: :uuid, on_delete: :delete_all), null: false
      add :draft_player_id, references(:draft_players, on_delete: :delete_all), null: false
      add :card_id, references(:cards, type: :uuid, on_delete: :nothing), null: false
      add :expires_at, :utc_datetime, null: false

      # 1, 2, or 3
      add :pack_number, :integer, null: false
      # Order of the pick within the pack
      add :pick_number, :integer, null: false

      timestamps()
    end

    create index(:draft_picks, [:draft_id])
    create index(:draft_picks, [:draft_player_id])
    create index(:draft_picks, [:card_id])
  end
end

=== File: priv/repo/seeds.exs ===

alias MtgDraftServer.Repo
alias MtgDraftServer.Cards.Card

"priv/repo/data/oracle_cards.json"
|> File.read!()
|> Jason.decode!()
|> Enum.each(fn card_attrs ->
  # Map the "set" key to "set_code" if it exists.
  card_attrs =
    if Map.has_key?(card_attrs, "set") do
      Map.put(card_attrs, "set_code", card_attrs["set"])
    else
      card_attrs
    end

  %Card{}
  |> Card.changeset(card_attrs)
  |> Repo.insert!(on_conflict: :nothing)
end)

=== File: priv/static/robots.txt ===

# See https://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file
#
# To ban all spiders from the entire site uncomment the next two lines:
# User-agent: *
# Disallow: /
