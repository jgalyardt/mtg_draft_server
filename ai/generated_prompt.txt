I am building an elixir Magic: The Gathering draft server with Phoenix.
Firebase will handle the hosting. Only authenticated users should be able to call any endpoint.

I need help adding CORS. My web app is running on port 5173.

Here are the project files:
=== File: lib/mtg_draft_server/application.ex ===

defmodule MtgDraftServer.Application do
  # See https://hexdocs.pm/elixir/Application.html
  # for more information on OTP Applications
  @moduledoc false

  use Application

  @impl true
  def start(_type, _args) do
    children = [
      MtgDraftServerWeb.Telemetry,
      MtgDraftServer.Repo,
      {DNSCluster, query: Application.get_env(:mtg_draft_server, :dns_cluster_query) || :ignore},
      {Phoenix.PubSub, name: MtgDraftServer.PubSub},
      # Start the Finch HTTP client for sending emails
      {Finch, name: MtgDraftServer.Finch},
      # Start a worker by calling: MtgDraftServer.Worker.start_link(arg)
      # {MtgDraftServer.Worker, arg},
      # Start to serve requests, typically the last entry
      MtgDraftServerWeb.Endpoint,
      # Add the Registry and Dynamic Supervisor for draft sessions:
      {Registry, keys: :unique, name: MtgDraftServer.DraftRegistry},
      MtgDraftServer.DraftSessionSupervisor
    ]

    # See https://hexdocs.pm/elixir/Supervisor.html
    # for other strategies and supported options
    opts = [strategy: :one_for_one, name: MtgDraftServer.Supervisor]
    Supervisor.start_link(children, opts)
  end

  # Tell Phoenix to update the endpoint configuration
  # whenever the application is updated.
  @impl true
  def config_change(changed, _new, removed) do
    MtgDraftServerWeb.Endpoint.config_change(changed, removed)
    :ok
  end
end

=== File: lib/mtg_draft_server/auth_error_handler.ex ===

defmodule MtgDraftServer.AuthErrorHandler do
  import Plug.Conn

  def auth_error(conn, {type, _reason}, _opts) do
    body = Jason.encode!(%{error: to_string(type)})

    conn
    |> put_resp_content_type("application/json")
    |> send_resp(401, body)
  end
end

=== File: lib/mtg_draft_server/cards/card.ex ===

defmodule MtgDraftServer.Cards.Card do
  use Ecto.Schema
  import Ecto.Changeset

  # we use the Scryfall id as primary key
  @primary_key {:id, :binary_id, autogenerate: false}
  schema "cards" do
    field :oracle_id, Ecto.UUID
    field :name, :string
    field :mana_cost, :string
    field :cmc, :float
    field :type_line, :string
    field :oracle_text, :string
    field :power, :string
    field :toughness, :string
    field :colors, {:array, :string}
    field :color_identity, {:array, :string}
    field :image_uris, :map
    field :legalities, :map

    timestamps()
  end

  @doc false
  def changeset(card, attrs) do
    card
    |> cast(attrs, [
      :id,
      :oracle_id,
      :name,
      :mana_cost,
      :cmc,
      :type_line,
      :oracle_text,
      :power,
      :toughness,
      :colors,
      :color_identity,
      :image_uris,
      :legalities
    ])
    |> validate_required([:id, :oracle_id, :name])
  end
end

=== File: lib/mtg_draft_server/drafts/draft.ex ===

defmodule MtgDraftServer.Drafts.Draft do
  use Ecto.Schema
  import Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: true}
  schema "drafts" do
    field :status, :string, default: "pending"
    field :creator, :string
    timestamps()
  end

  def changeset(draft, attrs) do
    draft
    |> cast(attrs, [:status, :creator])
    |> validate_required([:status])
  end
end

=== File: lib/mtg_draft_server/drafts/draft_pick.ex ===

defmodule MtgDraftServer.Drafts.DraftPick do
  use Ecto.Schema
  import Ecto.Changeset

  schema "draft_picks" do
    field :card_id, :binary_id
    field :pack_number, :integer
    field :pick_number, :integer
    field :expires_at, :utc_datetime
    belongs_to :draft, MtgDraftServer.Drafts.Draft, type: :binary_id
    belongs_to :draft_player, MtgDraftServer.Drafts.DraftPlayer

    timestamps()
  end

  def changeset(draft_pick, attrs) do
    draft_pick
    |> cast(attrs, [
      :draft_id,
      :draft_player_id,
      :card_id,
      :pack_number,
      :pick_number,
      :expires_at
    ])
    |> validate_required([
      :draft_id,
      :draft_player_id,
      :card_id,
      :pack_number,
      :pick_number,
      :expires_at
    ])
  end
end

=== File: lib/mtg_draft_server/drafts/draft_player.ex ===

defmodule MtgDraftServer.Drafts.DraftPlayer do
  use Ecto.Schema
  import Ecto.Changeset

  schema "draft_players" do
    field :user_id, :string
    field :seat, :integer
    field :connected, :boolean, default: true
    belongs_to :draft, MtgDraftServer.Drafts.Draft, type: :binary_id

    timestamps()
  end

  def changeset(draft_player, attrs) do
    draft_player
    |> cast(attrs, [:draft_id, :user_id, :seat, :connected])
    |> validate_required([:draft_id, :user_id, :seat])
  end

  def create_draft_player(attrs) do
    %__MODULE__{}
    |> changeset(attrs)
    |> MtgDraftServer.Repo.insert()
  end
end

=== File: lib/mtg_draft_server/drafts.ex ===

defmodule MtgDraftServer.Drafts do
  @moduledoc """
  Context for managing drafts, players, and picks.
  This module handles all draft-related operations including creation,
  starting drafts, making picks, and retrieving draft information.
  """

  import Ecto.Query, warn: false
  alias MtgDraftServer.Repo
  alias MtgDraftServer.Drafts.{Draft, DraftPlayer, DraftPick}

  @one_day_in_seconds 86400

  @type error :: {:error, Ecto.Changeset.t() | String.t()}
  @type draft_result :: {:ok, Draft.t()} | error
  @type pick_result :: {:ok, DraftPick.t()} | error
  @type player_result :: {:ok, DraftPlayer.t()} | error

  @doc """
  Creates a new draft with an optional creator.

  ## Parameters
    * `attrs` - Map of attributes which may include:
      * `:creator` - User ID of the draft creator
      
  ## Returns
    * `{:ok, draft}` on success
    * `{:error, changeset}` on validation failure
    * `{:error, reason}` on other failures

  ## Examples
      iex> create_draft(%{creator: "user123"})
      {:ok, %Draft{}}

      iex> create_draft(%{invalid: "params"})
      {:error, %Ecto.Changeset{}}
  """
  @spec create_draft(map()) :: draft_result
  def create_draft(attrs \\ %{}) do
    Repo.transaction(fn ->
      with {:ok, draft} <- do_create_draft(attrs),
           {:ok, _player} <- maybe_create_player(draft, attrs[:creator]) do
        draft
      else
        error -> Repo.rollback(error)
      end
    end)
  end

  @doc """
  Creates a new draft, starts its draft-session GenServer,
  and joins the creator (if provided).
  """
  @spec create_and_join_draft(map()) :: {:ok, Draft.t()} | {:error, any()}
  def create_and_join_draft(attrs \\ %{}) do
    Repo.transaction(fn ->
      with {:ok, draft} <- do_create_draft(attrs),
           {:ok, _player} <- maybe_create_player(draft, attrs[:creator]) do
        # Start a new draft session process for this draft.
        {:ok, _pid} = MtgDraftServer.DraftSessionSupervisor.start_new_session(draft.id)
        # Have the creator join the session.
        if attrs[:creator] do
          :ok = MtgDraftServer.DraftSession.join(draft.id, %{user_id: attrs[:creator], seat: 1})
        end

        draft
      else
        error -> Repo.rollback(error)
      end
    end)
  end

  @doc """
  Retrieves the most recent active draft for a given user.
  (An active draft is one whose status is either "pending" or "active".)
  """
  @spec get_active_draft_for_player(String.t()) :: DraftPlayer.t() | nil
  def get_active_draft_for_player(user_id) do
    query =
      from dp in DraftPlayer,
        join: d in Draft,
        on: dp.draft_id == d.id,
        where: dp.user_id == ^user_id and d.status in ["pending", "active"],
        order_by: [desc: dp.inserted_at],
        limit: 1,
        preload: [:draft]

    Repo.one(query)
  end

  @doc """
  Starts a draft by updating its status to "active".
  Validates that the draft exists and has the required number of players.

  ## Parameters
    * `draft_id` - The ID of the draft to start

  ## Returns
    * `{:ok, draft}` on success
    * `{:error, reason}` on failure
  """
  @spec start_draft(binary()) :: draft_result
  def start_draft(draft_id) do
    with {:ok, draft} <- get_draft(draft_id),
         :ok <- validate_draft_can_start(draft),
         {:ok, updated_draft} <- do_start_draft(draft) do
      broadcast_draft_update(draft_id, :draft_started)
      {:ok, updated_draft}
    end
  end

  @doc """
  Records a card pick in the draft.
  Validates the pick is legal and updates the draft state accordingly.

  ## Parameters
    * `draft_id` - The ID of the draft
    * `user_id` - The ID of the user making the pick
    * `card_id` - The ID of the picked card
    * `extra_attrs` - Additional attributes including:
      * `"pack_number"` - Current pack number
      * `"pick_number"` - Current pick number within the pack

  ## Returns
    * `{:ok, pick}` on success
    * `{:error, reason}` on failure
  """
  @spec pick_card(binary(), binary(), binary(), map()) :: pick_result
  def pick_card(draft_id, user_id, card_id, extra_attrs \\ %{}) do
    start_time = System.monotonic_time()

    result =
      with {:ok, draft} <- get_draft(draft_id),
           :ok <- validate_draft_active(draft),
           {:ok, draft_player} <- get_draft_player(draft_id, user_id),
           :ok <- validate_can_pick(draft_player, extra_attrs),
           {:ok, pick} <- do_create_pick(draft_id, draft_player, card_id, extra_attrs) do
        broadcast_draft_update(draft_id, {:pick_made, pick})
        {:ok, pick}
      end

    # Record telemetry
    end_time = System.monotonic_time()

    :telemetry.execute(
      [:mtg_draft_server, :drafts, :pick_card],
      %{duration: end_time - start_time},
      %{draft_id: draft_id, user_id: user_id}
    )

    result
  end

  @doc """
  Retrieves all picks for a given draft and user.

  ## Parameters
    * `draft_id` - The ID of the draft
    * `user_id` - The ID of the user whose picks to retrieve

  ## Returns
    * List of picks ordered by insertion time
    * Empty list if no picks found
  """
  @spec get_picked_cards(binary(), binary()) :: [DraftPick.t()]
  def get_picked_cards(draft_id, user_id) do
    with {:ok, draft_player} <- get_draft_player(draft_id, user_id) do
      query =
        from pick in DraftPick,
          where: pick.draft_player_id == ^draft_player.id,
          order_by: [asc: pick.inserted_at],
          preload: [:card]

      Repo.all(query)
    else
      _error -> []
    end
  end

  @doc """
  Gets a draft by ID.

  Returns `{:ok, draft}` if found, `{:error, "Draft not found"}` if not found.
  """
  @spec get_draft(binary()) :: draft_result
  def get_draft(draft_id) do
    case Cachex.get(:draft_cache, "draft:#{draft_id}") do
      {:ok, draft} when not is_nil(draft) ->
        {:ok, draft}

      _ ->
        case Repo.get(Draft, draft_id) do
          nil ->
            {:error, "Draft not found"}

          draft ->
            Cachex.put(:draft_cache, "draft:#{draft_id}", draft, ttl: :timer.minutes(5))
            {:ok, draft}
        end
    end
  end

  # Private helper functions

  defp do_create_draft(attrs) do
    %Draft{}
    |> Draft.changeset(attrs)
    |> Repo.insert()
  end

  defp do_start_draft(draft) do
    draft
    |> Draft.changeset(%{status: "active"})
    |> Repo.update()
  end

  defp do_create_pick(draft_id, draft_player, card_id, extra_attrs) do
    now = DateTime.utc_now() |> DateTime.truncate(:second)
    expires_at = DateTime.add(now, @one_day_in_seconds, :second)

    attrs =
      Map.merge(extra_attrs, %{
        "draft_id" => draft_id,
        "draft_player_id" => draft_player.id,
        "card_id" => card_id,
        "expires_at" => expires_at
      })

    %DraftPick{}
    |> DraftPick.changeset(attrs)
    |> Repo.insert()
  end

  defp get_draft_player(draft_id, user_id) do
    case Repo.one(
           from dp in DraftPlayer,
             where: dp.draft_id == ^draft_id and dp.user_id == ^user_id,
             preload: [:draft]
         ) do
      nil -> {:error, "Player not found in draft"}
      player -> {:ok, player}
    end
  end

  defp maybe_create_player(_draft, nil), do: {:ok, nil}

  defp maybe_create_player(draft, creator) do
    DraftPlayer.create_draft_player(%{
      draft_id: draft.id,
      user_id: creator,
      seat: 1
    })
  end

  defp validate_draft_can_start(draft) do
    with :ok <- validate_draft_status(draft),
         :ok <- validate_player_count(draft) do
      :ok
    end
  end

  defp validate_draft_status(draft) do
    if draft.status == "pending" do
      :ok
    else
      {:error, "Draft cannot be started from #{draft.status} status"}
    end
  end

  defp validate_player_count(draft) do
    player_count =
      Repo.one(from dp in DraftPlayer, where: dp.draft_id == ^draft.id, select: count(dp.id))

    if player_count >= 2 do
      :ok
    else
      {:error, "Draft needs at least 2 players to start"}
    end
  end

  defp validate_draft_active(draft) do
    if draft.status == "active" do
      :ok
    else
      {:error, "Draft is not active"}
    end
  end

  defp validate_can_pick(draft_player, attrs) do
    with :ok <- validate_pack_number(attrs["pack_number"]),
         :ok <- validate_pick_number(attrs["pick_number"]),
         :ok <- validate_player_turn(draft_player, attrs) do
      :ok
    end
  end

  defp validate_pack_number(pack_number) when pack_number in 1..3, do: :ok
  defp validate_pack_number(_), do: {:error, "Invalid pack number"}

  defp validate_pick_number(pick_number) when pick_number in 1..15, do: :ok
  defp validate_pick_number(_), do: {:error, "Invalid pick number"}

  defp validate_player_turn(_draft_player, _attrs) do
    # Add logic to verify it's this player's turn to pick
    # This would depend on your specific draft rules
    :ok
  end

  defp broadcast_draft_update(draft_id, event) do
    Phoenix.PubSub.broadcast(
      MtgDraftServer.PubSub,
      "draft:#{draft_id}",
      {event, draft_id}
    )
  end
end

=== File: lib/mtg_draft_server/draft_session.ex ===

defmodule MtgDraftServer.DraftSession do
  use GenServer

  @moduledoc """
  A GenServer that represents a draft session.
  """

  ## Client API

  @doc """
  Starts a draft session for a given draft_id.
  """
  def start_link(draft_id) do
    GenServer.start_link(__MODULE__, draft_id, name: via_tuple(draft_id))
  end

  @doc """
  Allows a player to join a draft session.
  """
  def join(draft_id, player) do
    GenServer.call(via_tuple(draft_id), {:join, player})
  end

  @doc """
  Retrieve the current state of the draft session.
  """
  def get_state(draft_id) do
    GenServer.call(via_tuple(draft_id), :get_state)
  end

  ## Helper for Registry lookup

  defp via_tuple(draft_id) do
    {:via, Registry, {MtgDraftServer.DraftRegistry, draft_id}}
  end

  ## Server Callbacks

  @impl true
  def init(draft_id) do
    state = %{
      draft_id: draft_id,
      # a map of user_id => player info
      players: %{},
      status: :pending
    }

    {:ok, state}
  end

  @impl true
  def handle_call({:join, player}, _from, state) do
    new_players = Map.put(state.players, player.user_id, player)

    new_state = %{state | players: new_players}

    # If the draft has reached 8 players, update the state and trigger any side effects
    new_state =
      if map_size(new_players) >= 8 and state.status != :active do
        # You might also want to persist this change to the DB
        broadcast_draft_started(state.draft_id)
        # Also trigger the creation of a new draft session so that new players aren’t
        # forced into a draft that is already full.
        spawn_new_draft()
        %{new_state | status: :active}
      else
        new_state
      end

    {:reply, :ok, new_state}
  end

  @impl true
  def handle_call(:get_state, _from, state) do
    {:reply, state, state}
  end

  defp broadcast_draft_started(draft_id) do
    Phoenix.PubSub.broadcast(
      MtgDraftServer.PubSub,
      "draft:#{draft_id}",
      {:draft_started, draft_id}
    )
  end

  defp spawn_new_draft do
    # For example, generate a new UUID for the draft (or use your Ecto workflow)
    new_draft_id = Ecto.UUID.generate()
    # You can also create a record in the database here if desired.
    MtgDraftServer.DraftSessionSupervisor.start_new_session(new_draft_id)
  end
end

=== File: lib/mtg_draft_server/draft_session_supervisor.ex ===

defmodule MtgDraftServer.DraftSessionSupervisor do
  use DynamicSupervisor

  def start_link(_args) do
    DynamicSupervisor.start_link(__MODULE__, :ok, name: __MODULE__)
  end

  @impl true
  def init(:ok) do
    DynamicSupervisor.init(strategy: :one_for_one)
  end

  @doc """
  Starts a new draft session.
  """
  def start_new_session(draft_id) do
    spec = {MtgDraftServer.DraftSession, draft_id}
    DynamicSupervisor.start_child(__MODULE__, spec)
  end
end

=== File: lib/mtg_draft_server/guardian.ex ===

defmodule MtgDraftServer.Guardian do
  use Guardian, otp_app: :mtg_draft_server

  @doc """
  Encode the resource into the token. In this example the resource is expected
  to be a map with a `uid` key (such as coming from Firebase or your user table).
  """
  def subject_for_token(resource, _claims) do
    sub = to_string(resource.uid)
    {:ok, sub}
  end

  @doc """
  Given the claims, return the resource. Typically you’d query your database here.
  For now we just return a dummy user with the uid.
  """
  def resource_from_claims(claims) do
    uid = claims["sub"]
    {:ok, %{uid: uid}}
  end
end

=== File: lib/mtg_draft_server/repo.ex ===

defmodule MtgDraftServer.Repo do
  use Ecto.Repo,
    otp_app: :mtg_draft_server,
    adapter: Ecto.Adapters.Postgres
end

=== File: lib/mtg_draft_server.ex ===

defmodule MtgDraftServer do
  @moduledoc """
  MtgDraftServer keeps the contexts that define your domain
  and business logic.

  Contexts are also responsible for managing your data, regardless
  if it comes from the database, an external API or others.
  """
end

=== File: lib/mtg_draft_server_web/controllers/default_controller.ex ===

# lib/mtg_draft_server_web/controllers/default_controller.ex
defmodule MtgDraftServerWeb.DefaultController do
  use MtgDraftServerWeb, :controller

  def index(conn, _params) do
    json(conn, %{
      message: "Welcome to MTG Draft Server API",
      version: "1.0",
      endpoints: %{
        drafts: %{
          create: "POST /api/drafts",
          start: "POST /api/drafts/:id/start",
          pick: "POST /api/drafts/:id/pick",
          picked_cards: "GET /api/drafts/:id/picks"
        }
      }
    })
  end
end

=== File: lib/mtg_draft_server_web/controllers/draft_controller.ex ===

defmodule MtgDraftServerWeb.DraftController do
  use MtgDraftServerWeb, :controller

  alias MtgDraftServer.Drafts
  alias MtgDraftServer.Guardian

  action_fallback MtgDraftServerWeb.FallbackController

  @doc """
  Create a new draft. The current user (from Guardian) is recorded as the creator.
  POST /api/drafts
  """
  def create(conn, _params) do
    case Guardian.Plug.current_resource(conn) do
      nil ->
        {:error, "Authentication required"}

      current_user ->
        with {:ok, draft} <- Drafts.create_and_join_draft(%{creator: current_user.uid}) do
          conn
          |> put_status(:created)
          |> put_resp_header("location", "/api/drafts/#{draft.id}")
          |> json(%{draft_id: draft.id, status: draft.status})
        end
    end
  end

  @doc """
  Start the draft by updating its status to "active".
  POST /api/drafts/:id/start
  """
  def start(conn, %{"id" => draft_id}) do
    with {:ok, current_user} <- fetch_current_user(conn),
         {:ok, draft} <- Drafts.start_draft(draft_id),
         {:ok, _authorized} <- authorize_draft_action(draft, current_user) do
      json(conn, %{draft_id: draft.id, status: draft.status})
    end
  end

  @doc """
  Persist a card pick.
  POST /api/drafts/:id/pick
  """
  def pick(conn, %{
        "id" => draft_id,
        "card_id" => card_id,
        "pack_number" => pack_number,
        "pick_number" => pick_number
      }) do
    with {:ok, current_user} <- fetch_current_user(conn),
         {:ok, _} <- ensure_in_draft_session(draft_id, current_user.uid),
         {:ok, draft} <- Drafts.get_draft(draft_id),
         {:ok, _authorized} <- authorize_draft_action(draft, current_user),
         {:ok, pick} <-
           Drafts.pick_card(draft_id, current_user.uid, card_id, %{
             "pack_number" => pack_number,
             "pick_number" => pick_number
           }) do
      conn
      |> put_status(:created)
      |> json(%{pick: pick})
    end
  end

  @doc """
  Reconnect a user to their active draft session.
  POST /api/drafts/reconnect

  If a draft session exists, the user rejoins it. If no session exists but the user
  has an active draft, a new session is started and the user joins it.
  """
  def reconnect(conn, _params) do
    with {:ok, current_user} <- fetch_current_user(conn),
         draft_player when not is_nil(draft_player) <-
           Drafts.get_active_draft_for_player(current_user.uid) do
      draft_id = draft_player.draft.id

      case Registry.lookup(MtgDraftServer.DraftRegistry, draft_id) do
        [{_pid, _}] ->
          # The draft session exists; join the session.
          :ok = MtgDraftServer.DraftSession.join(draft_id, %{user_id: current_user.uid})
          json(conn, %{message: "Rejoined draft", draft_id: draft_id})

        [] ->
          # The draft session is not running; start it and then join.
          {:ok, _pid} = MtgDraftServer.DraftSessionSupervisor.start_new_session(draft_id)
          :ok = MtgDraftServer.DraftSession.join(draft_id, %{user_id: current_user.uid})
          json(conn, %{message: "Draft session restarted and rejoined", draft_id: draft_id})
      end
    else
      nil ->
        conn |> put_status(:not_found) |> json(%{error: "No active draft found for user"})

      {:error, reason} ->
        conn |> put_status(:bad_request) |> json(%{error: reason})
    end
  end

  @doc """
  Get all picks for the current user in a given draft.
  GET /api/drafts/:id/picks
  """
  def picked_cards(conn, %{"id" => draft_id}) do
    with {:ok, current_user} <- fetch_current_user(conn),
         {:ok, draft} <- Drafts.get_draft(draft_id),
         {:ok, _authorized} <- authorize_draft_action(draft, current_user) do
      picks = Drafts.get_picked_cards(draft_id, current_user.uid)
      json(conn, %{picks: picks})
    end
  end

  # Helper functions
  defp ensure_in_draft_session(draft_id, user_id) do
    # Calling join/2 on the draft session is idempotent.
    :ok = MtgDraftServer.DraftSession.join(draft_id, %{user_id: user_id})
    {:ok, :joined}
  end

  defp fetch_current_user(conn) do
    case Guardian.Plug.current_resource(conn) do
      nil -> {:error, "Authentication required"}
      user -> {:ok, user}
    end
  end

  defp authorize_draft_action(draft, user) do
    cond do
      draft.creator == user.uid -> {:ok, true}
      # Add more authorization conditions here
      true -> {:error, "Unauthorized"}
    end
  end
end

=== File: lib/mtg_draft_server_web/controllers/error_json.ex ===

defmodule MtgDraftServerWeb.ErrorJSON do
  @moduledoc """
  This module is invoked by your endpoint in case of errors on JSON requests.

  See config/config.exs.
  """

  # If you want to customize a particular status code,
  # you may add your own clauses, such as:
  #
  # def render("500.json", _assigns) do
  #   %{errors: %{detail: "Internal Server Error"}}
  # end

  # By default, Phoenix returns the status message from
  # the template name. For example, "404.json" becomes
  # "Not Found".
  def render(template, _assigns) do
    %{errors: %{detail: Phoenix.Controller.status_message_from_template(template)}}
  end
end

=== File: lib/mtg_draft_server_web/controllers/fallback_controller.ex ===

defmodule MtgDraftServerWeb.FallbackController do
  use MtgDraftServerWeb, :controller

  # For Ecto errors, you might pattern match like this:
  def call(conn, {:error, %Ecto.Changeset{} = changeset}) do
    conn
    |> put_status(:unprocessable_entity)
    |> json(%{errors: changeset})
  end

  def call(conn, {:error, message}) when is_binary(message) do
    conn
    |> put_status(:bad_request)
    |> json(%{error: message})
  end
end

=== File: lib/mtg_draft_server_web/endpoint.ex ===

defmodule MtgDraftServerWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :mtg_draft_server

  # Force SSL in production if configured
  if Application.compile_env(:mtg_draft_server, :force_ssl, false) do
    plug Plug.SSL, rewrite_on: [:x_forwarded_proto]
  end

  # The session will be stored in the cookie and signed,
  # this means its contents can be read but not tampered with.
  # Set :encryption_salt if you would also like to encrypt it.
  @session_options [
    store: :cookie,
    key: "_mtg_draft_server_key",
    signing_salt: "WOTNq3DB",
    same_site: "Lax"
  ]

  # socket "/live", Phoenix.LiveView.Socket,
  #   websocket: [connect_info: [session: @session_options]],
  #   longpoll: [connect_info: [session: @session_options]]

  # Serve at "/" the static files from "priv/static" directory.
  #
  # You should set gzip to true if you are running phx.digest
  # when deploying your static files in production.
  plug Plug.Static,
    at: "/",
    from: :mtg_draft_server,
    gzip: false,
    only: MtgDraftServerWeb.static_paths()

  # Code reloading can be explicitly enabled under the
  # :code_reloader configuration of your endpoint.
  if code_reloading? do
    plug Phoenix.CodeReloader
    plug Phoenix.Ecto.CheckRepoStatus, otp_app: :mtg_draft_server
  end

  plug Plug.RequestId
  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

  plug Plug.Parsers,
    parsers: [:urlencoded, :multipart, :json],
    pass: ["*/*"],
    json_decoder: Phoenix.json_library()

  plug Plug.MethodOverride
  plug Plug.Head
  plug Plug.Session, @session_options
  plug MtgDraftServerWeb.Router
end

=== File: lib/mtg_draft_server_web/gettext.ex ===

defmodule MtgDraftServerWeb.Gettext do
  @moduledoc """
  A module providing Internationalization with a gettext-based API.

  By using [Gettext](https://hexdocs.pm/gettext),
  your module gains a set of macros for translations, for example:

      import MtgDraftServerWeb.Gettext

      # Simple translation
      gettext("Here is the string to translate")

      # Plural translation
      ngettext("Here is the string to translate",
               "Here are the strings to translate",
               3)

      # Domain-based translation
      dgettext("errors", "Here is the error message to translate")

  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.
  """
  use Gettext.Backend, otp_app: :mtg_draft_server
end

=== File: lib/mtg_draft_server_web/router.ex ===

defmodule MtgDraftServerWeb.Router do
  use MtgDraftServerWeb, :router

  pipeline :api do
    plug :accepts, ["json"]

    # Guardian pipeline
    plug Guardian.Plug.Pipeline,
      module: MtgDraftServer.Guardian,
      error_handler: MtgDraftServer.AuthErrorHandler

    plug Guardian.Plug.VerifyHeader, scheme: "Bearer"
    plug Guardian.Plug.LoadResource, allow_blank: false
  end

  # Add a new pipeline for public routes that don't need authentication
  pipeline :public_api do
    plug :accepts, ["json"]
  end

  # Add a public scope for routes that don't need authentication
  scope "/", MtgDraftServerWeb do
    pipe_through :public_api

    get "/", DefaultController, :index
  end

  scope "/api", MtgDraftServerWeb do
    pipe_through :api
  
    post "/drafts", DraftController, :create
    post "/drafts/:id/start", DraftController, :start
    post "/drafts/:id/pick", DraftController, :pick
    get "/drafts/:id/picks", DraftController, :picked_cards
    post "/drafts/reconnect", DraftController, :reconnect
  end
  
end

=== File: lib/mtg_draft_server_web/telemetry.ex ===

defmodule MtgDraftServerWeb.Telemetry do
  use Supervisor
  import Telemetry.Metrics

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  @impl true
  def init(_arg) do
    children = [
      # Telemetry poller will execute the given period measurements
      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics
      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}
      # Add reporters as children of your supervision tree.
      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end

  def metrics do
    [
      # Phoenix Metrics
      summary("phoenix.endpoint.start.system_time",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.endpoint.stop.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.start.system_time",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.exception.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.stop.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.socket_connected.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.channel_joined.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.channel_handled_in.duration",
        tags: [:event],
        unit: {:native, :millisecond}
      ),

      # Database Metrics
      summary("mtg_draft_server.repo.query.total_time",
        unit: {:native, :millisecond},
        description: "The sum of the other measurements"
      ),
      summary("mtg_draft_server.repo.query.decode_time",
        unit: {:native, :millisecond},
        description: "The time spent decoding the data received from the database"
      ),
      summary("mtg_draft_server.repo.query.query_time",
        unit: {:native, :millisecond},
        description: "The time spent executing the query"
      ),
      summary("mtg_draft_server.repo.query.queue_time",
        unit: {:native, :millisecond},
        description: "The time spent waiting for a database connection"
      ),
      summary("mtg_draft_server.repo.query.idle_time",
        unit: {:native, :millisecond},
        description:
          "The time the connection spent waiting before being checked out for the query"
      ),

      # VM Metrics
      summary("vm.memory.total", unit: {:byte, :kilobyte}),
      summary("vm.total_run_queue_lengths.total"),
      summary("vm.total_run_queue_lengths.cpu"),
      summary("vm.total_run_queue_lengths.io")
    ]
  end

  defp periodic_measurements do
    [
      # A module, function and arguments to be invoked periodically.
      # This function must call :telemetry.execute/3 and a metric must be added above.
      # {MtgDraftServerWeb, :count_users, []}
    ]
  end
end

=== File: lib/mtg_draft_server_web.ex ===

defmodule MtgDraftServerWeb do
  @moduledoc """
  The entrypoint for defining your web interface, such
  as controllers, components, channels, and so on.

  This can be used in your application as:

      use MtgDraftServerWeb, :controller
      use MtgDraftServerWeb, :html

  The definitions below will be executed for every controller,
  component, etc, so keep them short and clean, focused
  on imports, uses and aliases.

  Do NOT define functions inside the quoted expressions
  below. Instead, define additional modules and import
  those modules here.
  """

  def static_paths, do: ~w(assets fonts images favicon.ico robots.txt)

  def router do
    quote do
      use Phoenix.Router, helpers: false

      # Import common connection and controller functions to use in pipelines
      import Plug.Conn
      import Phoenix.Controller
    end
  end

  def channel do
    quote do
      use Phoenix.Channel
    end
  end

  def controller do
    quote do
      use Phoenix.Controller,
        formats: [:html, :json],
        layouts: [html: MtgDraftServerWeb.Layouts]

      import Plug.Conn
      import MtgDraftServerWeb.Gettext

      unquote(verified_routes())
    end
  end

  def verified_routes do
    quote do
      use Phoenix.VerifiedRoutes,
        endpoint: MtgDraftServerWeb.Endpoint,
        router: MtgDraftServerWeb.Router,
        statics: MtgDraftServerWeb.static_paths()
    end
  end

  @doc """
  When used, dispatch to the appropriate controller/live_view/etc.
  """
  defmacro __using__(which) when is_atom(which) do
    apply(__MODULE__, which, [])
  end
end

=== File: mix.exs ===

defmodule MtgDraftServer.MixProject do
  use Mix.Project

  def project do
    [
      app: :mtg_draft_server,
      version: "0.1.0",
      elixir: "~> 1.14",
      elixirc_paths: elixirc_paths(Mix.env()),
      start_permanent: Mix.env() == :prod,
      aliases: aliases(),
      deps: deps()
    ]
  end

  # Configuration for the OTP application.
  #
  # Type `mix help compile.app` for more information.
  def application do
    [
      mod: {MtgDraftServer.Application, []},
      extra_applications: [:logger, :runtime_tools]
    ]
  end

  # Specifies which paths to compile per environment.
  defp elixirc_paths(:test), do: ["lib", "test/support"]
  defp elixirc_paths(_), do: ["lib"]

  # Specifies your project dependencies.
  #
  # Type `mix help deps` for examples and options.
  defp deps do
    [
      {:phoenix, "~> 1.7.14"},
      {:phoenix_ecto, "~> 4.5"},
      {:ecto_sql, "~> 3.10"},
      {:postgrex, ">= 0.0.0"},
      {:swoosh, "~> 1.5"},
      {:finch, "~> 0.13"},
      {:telemetry_metrics, "~> 1.0"},
      {:telemetry_poller, "~> 1.0"},
      {:gettext, "~> 0.20"},
      {:jason, "~> 1.2"},
      {:dns_cluster, "~> 0.1.1"},
      {:bandit, "~> 1.5"},
      {:guardian, "~> 2.3"},
      {:cachex, "~> 3.6"}
    ]
  end

  # Aliases are shortcuts or tasks specific to the current project.
  # For example, to install project dependencies and perform other setup tasks, run:
  #
  #     $ mix setup
  #
  # See the documentation for `Mix` for more info on aliases.
  defp aliases do
    [
      setup: ["deps.get", "ecto.setup"],
      "ecto.setup": ["ecto.create", "ecto.migrate", "run priv/repo/seeds.exs"],
      "ecto.reset": ["ecto.drop", "ecto.setup"],
      test: ["ecto.create --quiet", "ecto.migrate --quiet", "test"]
    ]
  end
end

=== File: priv/gettext/en/LC_MESSAGES/errors.po ===

## `msgid`s in this file come from POT (.pot) files.
##
## Do not add, change, or remove `msgid`s manually here as
## they're tied to the ones in the corresponding POT file
## (with the same domain).
##
## Use `mix gettext.extract --merge` or `mix gettext.merge`
## to merge POT files into PO files.
msgid ""
msgstr ""
"Language: en\n"

## From Ecto.Changeset.cast/4
msgid "can't be blank"
msgstr ""

## From Ecto.Changeset.unique_constraint/3
msgid "has already been taken"
msgstr ""

## From Ecto.Changeset.put_change/3
msgid "is invalid"
msgstr ""

## From Ecto.Changeset.validate_acceptance/3
msgid "must be accepted"
msgstr ""

## From Ecto.Changeset.validate_format/3
msgid "has invalid format"
msgstr ""

## From Ecto.Changeset.validate_subset/3
msgid "has an invalid entry"
msgstr ""

## From Ecto.Changeset.validate_exclusion/3
msgid "is reserved"
msgstr ""

## From Ecto.Changeset.validate_confirmation/3
msgid "does not match confirmation"
msgstr ""

## From Ecto.Changeset.no_assoc_constraint/3
msgid "is still associated with this entry"
msgstr ""

msgid "are still associated with this entry"
msgstr ""

## From Ecto.Changeset.validate_length/3
msgid "should have %{count} item(s)"
msgid_plural "should have %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} character(s)"
msgid_plural "should be %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} byte(s)"
msgid_plural "should be %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at least %{count} item(s)"
msgid_plural "should have at least %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} character(s)"
msgid_plural "should be at least %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} byte(s)"
msgid_plural "should be at least %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at most %{count} item(s)"
msgid_plural "should have at most %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} character(s)"
msgid_plural "should be at most %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} byte(s)"
msgid_plural "should be at most %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

## From Ecto.Changeset.validate_number/3
msgid "must be less than %{number}"
msgstr ""

msgid "must be greater than %{number}"
msgstr ""

msgid "must be less than or equal to %{number}"
msgstr ""

msgid "must be greater than or equal to %{number}"
msgstr ""

msgid "must be equal to %{number}"
msgstr ""

=== File: priv/gettext/errors.pot ===

## This is a PO Template file.
##
## `msgid`s here are often extracted from source code.
## Add new translations manually only if they're dynamic
## translations that can't be statically extracted.
##
## Run `mix gettext.extract` to bring this file up to
## date. Leave `msgstr`s empty as changing them here has no
## effect: edit them in PO (`.po`) files instead.
## From Ecto.Changeset.cast/4
msgid "can't be blank"
msgstr ""

## From Ecto.Changeset.unique_constraint/3
msgid "has already been taken"
msgstr ""

## From Ecto.Changeset.put_change/3
msgid "is invalid"
msgstr ""

## From Ecto.Changeset.validate_acceptance/3
msgid "must be accepted"
msgstr ""

## From Ecto.Changeset.validate_format/3
msgid "has invalid format"
msgstr ""

## From Ecto.Changeset.validate_subset/3
msgid "has an invalid entry"
msgstr ""

## From Ecto.Changeset.validate_exclusion/3
msgid "is reserved"
msgstr ""

## From Ecto.Changeset.validate_confirmation/3
msgid "does not match confirmation"
msgstr ""

## From Ecto.Changeset.no_assoc_constraint/3
msgid "is still associated with this entry"
msgstr ""

msgid "are still associated with this entry"
msgstr ""

## From Ecto.Changeset.validate_length/3
msgid "should have %{count} item(s)"
msgid_plural "should have %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} character(s)"
msgid_plural "should be %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be %{count} byte(s)"
msgid_plural "should be %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at least %{count} item(s)"
msgid_plural "should have at least %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} character(s)"
msgid_plural "should be at least %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at least %{count} byte(s)"
msgid_plural "should be at least %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should have at most %{count} item(s)"
msgid_plural "should have at most %{count} item(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} character(s)"
msgid_plural "should be at most %{count} character(s)"
msgstr[0] ""
msgstr[1] ""

msgid "should be at most %{count} byte(s)"
msgid_plural "should be at most %{count} byte(s)"
msgstr[0] ""
msgstr[1] ""

## From Ecto.Changeset.validate_number/3
msgid "must be less than %{number}"
msgstr ""

msgid "must be greater than %{number}"
msgstr ""

msgid "must be less than or equal to %{number}"
msgstr ""

msgid "must be greater than or equal to %{number}"
msgstr ""

msgid "must be equal to %{number}"
msgstr ""

=== File: priv/repo/migrations/20250208230004_create_cards.exs ===

defmodule MtgDraftServer.Repo.Migrations.CreateCards do
  use Ecto.Migration

  def change do
    create table(:cards, primary_key: false) do
      # Use the Scryfall card id (a UUID string) as the primary key.
      add :id, :uuid, primary_key: true
      add :oracle_id, :uuid, null: false
      add :name, :string, null: false
      add :mana_cost, :string
      add :cmc, :float
      add :type_line, :string
      add :oracle_text, :text
      add :power, :string
      add :toughness, :string
      add :colors, {:array, :string}
      add :color_identity, {:array, :string}
      # Store structured data such as image URIs and legalities as JSONB
      add :image_uris, :map
      add :legalities, :map

      timestamps()
    end

    create unique_index(:cards, [:oracle_id])
    create unique_index(:cards, [:name])
  end
end

=== File: priv/repo/migrations/20250209005129_create_drafts.exs ===

defmodule MtgDraftServer.Repo.Migrations.CreateDrafts do
  use Ecto.Migration

  def change do
    create table(:drafts, primary_key: false) do
      add :id, :uuid, primary_key: true
      # Use a string status (e.g., "pending", "active", "complete")
      add :status, :string, default: "pending"
      timestamps()
    end
  end
end

=== File: priv/repo/migrations/20250209005146_create_draft_players.exs ===

defmodule MtgDraftServer.Repo.Migrations.CreateDraftPlayers do
  use Ecto.Migration

  def change do
    create table(:draft_players) do
      add :draft_id, references(:drafts, type: :uuid, on_delete: :delete_all), null: false
      # Storing the Firebase UID (or any user identifier) as a string:
      add :user_id, :string, null: false
      add :seat, :integer, null: false
      # Optionally track connection status for handling disconnects:
      add :connected, :boolean, default: true

      timestamps()
    end

    create index(:draft_players, [:draft_id])
    create unique_index(:draft_players, [:draft_id, :user_id])
  end
end

=== File: priv/repo/migrations/20250209005217_create_draft_picks.exs ===

defmodule MtgDraftServer.Repo.Migrations.CreateDraftPicks do
  use Ecto.Migration

  def change do
    create table(:draft_picks) do
      add :draft_id, references(:drafts, type: :uuid, on_delete: :delete_all), null: false
      add :draft_player_id, references(:draft_players, on_delete: :delete_all), null: false
      add :card_id, references(:cards, type: :uuid, on_delete: :nothing), null: false
      # 1, 2, or 3
      add :pack_number, :integer, null: false
      # Order of the pick within the pack
      add :pick_number, :integer, null: false

      timestamps()
    end

    create index(:draft_picks, [:draft_id])
    create index(:draft_picks, [:draft_player_id])
    create index(:draft_picks, [:card_id])
  end
end

=== File: priv/repo/seeds.exs ===

# Script for populating the database. You can run it as:
#
#     mix run priv/repo/seeds.exs
#
# Inside the script, you can read and write to any of your
# repositories directly:
#
#     MtgDraftServer.Repo.insert!(%MtgDraftServer.SomeSchema{})
#
# We recommend using the bang functions (`insert!`, `update!`
# and so on) as they will fail if something goes wrong.
# priv/repo/seeds.exs
alias MtgDraftServer.Repo
alias MtgDraftServer.Cards.Card

# Adjust the path to your JSON file
"priv/repo/data/oracle_cards.json"
|> File.read!()
|> Jason.decode!()
|> Enum.each(fn card_attrs ->
  # Note: the keys in the JSON are strings. Your changeset above expects those keys.
  %Card{}
  |> Card.changeset(card_attrs)
  |> Repo.insert!()
end)

=== File: priv/static/robots.txt ===

# See https://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file
#
# To ban all spiders from the entire site uncomment the next two lines:
# User-agent: *
# Disallow: /
